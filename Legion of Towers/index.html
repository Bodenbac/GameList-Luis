<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legion of Towers</title>
    <!-- Add PeerJS CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>  
    <style>
        	/* ======================
            BASE STYLES 
            ====================== */
            html, body {
                margin: 0; 
                padding: 0; 
                width: 100vw; 
                height: 100vh; 
                overflow: hidden;
                background: linear-gradient(135deg, #356c3c 0%, #467943 100%);
            }

            /* ======================
            GAME CONTAINER & CANVAS 
            ====================== */
            #gameContainer { 
                position: relative; 
                width: 100vw; 
                height: 100vh; 
                overflow: hidden;
            }

            #gameCanvas { 
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: transparent; 
                pointer-events: auto;
                z-index: 10;
            }

            /* ======================
            USER INTERFACE (UI) 
            ====================== */
            #ui {
                position: absolute; 
                top: 10px; 
                left: 10px; 
                right: 10px; 
                z-index: 100;
                display: flex; 
                justify-content: space-between; 
                align-items: center;
                background: rgba(0,0,0,0.75); 
                padding: 10px 18px; 
                border-radius: 12px; 
                color: white;
            }

            #resources-left, #resources-right {
                display: flex; 
                align-items: center; 
                gap: 18px;
            }

            #resources-right .resource { 
                margin-left: 18px; 
            }

            .resource { 
                display: flex; 
                align-items: center; 
                gap: 7px; 
                font-weight: bold; 
                font-size: 1.12em; 
            }

            .ico { 
                width: 1.38em; 
                height: 1.38em; 
                vertical-align: middle; 
            }

            /* ======================
            BUTTONS 
            ====================== */
            #startButton { 
                position: absolute;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: #3498db;
                color: white;
                border: none;
                padding: 9px 22px;
                border-radius: 10px;
                font-size: 14px;
                cursor: pointer;
                transition: all 0.3s;
                box-shadow: 0 3px 16px #0006;
                z-index: 1000;
            }

            #startButton:hover {
                background: #2980b9;
                transform: translateX(-50%) scale(1.05);
            }

            #startButton:disabled {
                background: #7f8c8d;
                cursor: not-allowed;
                transform: translateX(-50%);
            }

            /* ======================
            MENUS (TOWER & UPGRADE) 
            ====================== */
            #towerMenu {
                position: absolute;
                z-index: 1000;
                display: none;
                background: rgba(0,0,0,0.93);
                border-radius: 14px;
                padding: 14px 13px;
                min-width: 240px;
                grid-template-columns: repeat(2, 1fr);
                gap: 13px;
                box-shadow: 0 4px 22px #000b;
                border: 2px solid #3498db;
            }

            #upgradeMenu {
                position: absolute;
                z-index: 1000;
                display: none;
                background: rgba(0,0,0,0.93);
                border-radius: 14px;
                padding: 8px;
                grid-template-columns: 1fr;
                gap: 8px;
                box-shadow: 0 4px 22px #000b;
                border: 2px solid #f1c40f;
                bottom: 20px;
                left: 20px;
                width: auto;
                max-width: calc(100% - 40px);
            }

            /* ======================
            TOWER OPTIONS 
            ====================== */
            .tower-option {
                background: linear-gradient(135deg, #3498db, #2980b9);
                color: white; 
                border: none; 
                border-radius: 8px;
                padding: 12px 3px 10px 3px; 
                cursor: pointer;
                font-size: 14px; 
                text-align: center; 
                min-height: 62px;
                display: flex; 
                flex-direction: column; 
                align-items: center; 
                gap: 4px;
                transition: all 0.2s;
            }

            /* Tower type variants */
            .tower-option.cannon {
                background: linear-gradient(135deg, #696969, #555555);
            }

            .tower-option.mage {
                background: linear-gradient(135deg, #6A5ACD, #4B0082);
            }

            .tower-option.fire {
                background: linear-gradient(135deg, #FF4500, #8B0000);
            }

            .tower-option.ice {
                background: linear-gradient(135deg, #007acc, #a0e1ff);
            }

            .tower-option.sniper {
                background: linear-gradient(135deg, #333333, #001f3f);
            }

            .tower-option:hover { 
                background: linear-gradient(135deg, #2980b9, #3498db); 
                transform: scale(1.04);
            }

            .tower-option.cannon:hover { 
                background: linear-gradient(135deg, #555555, #696969); 
            }

            .tower-option.mage:hover { 
                background: linear-gradient(135deg, #4B0082, #6A5ACD); 
            }

            .tower-option.fire:hover { 
                background: linear-gradient(135deg, #8B0000, #FF4500); 
            }

            .tower-option.ice:hover { 
                background: linear-gradient(135deg, #a0e1ff, #007acc); 
            }

            .tower-option.sniper:hover { 
                background: linear-gradient(135deg, #001f3f, #333333); 
            }

            /* ======================
            UPGRADE OPTIONS 
            ====================== */
            .upgrade-option {
                width: 100%;
                background: linear-gradient(135deg, #f39c12, #e67e22);
                color: white; 
                border: none; 
                border-radius: 8px;
                padding: 12px 3px 10px 3px; 
                cursor: pointer;
                font-size: 14px; 
                text-align: center; 
                min-height: 62px;
                display: flex; 
                flex-direction: column; 
                align-items: center; 
                gap: 4px;
                transition: all 0.2s;
            }

            .upgrade-option:hover { 
                background: linear-gradient(135deg, #e67e22, #f39c12); 
                transform: scale(1.04);
            }

            .tower-option:disabled, 
            .upgrade-option:disabled { 
                background: #7f8c8d; 
                cursor: not-allowed; 
            }

            /* ======================
            TYPOGRAPHY & TEXT ELEMENTS
            ====================== */
            .tower-name, 
            .upgrade-name { 
                font-weight: bold; 
                margin-bottom: 3px; 
            }

            .tower-cost, 
            .upgrade-cost { 
                font-size: 11px; 
                color: #f1c40f; 
                margin-top: 2px; 
            }

            .upgrade-description {
                font-size: 10px;
                color: #ccc;
                margin-top: 2px;
            }

            /* ======================
            TOWER ICONS
            ====================== */
            .tower-icon svg {
                width: 100%;
                height: 100%;
                pointer-events: none;
            }

            /* ======================
            STATS DISPLAYS
            ====================== */
            .tower-stats {
                grid-column: 1 / -1;
                background: rgba(0, 0, 0, 0.7);
                padding: 10px;
                border-radius: 8px;
                margin-bottom: 10px;
                color: white;
            }

            .enemy-info {
                background: rgba(0,0,0,0.93);
                border-radius: 14px;
                padding: 14px;
                border: 2px solid #f44336;
            }

            .enemy-info .stat-name {
                color: #f5a742;
            }

            .enemy-info .stat-value {
                color: white;
            }

            .enemy-info h3 {
                color: #f44336;
                margin-top: 0;
                margin-bottom: 10px;
            }

            .stat-row {
                display: flex;
                justify-content: space-between;
                margin: 5px 0;
            }

            .stat-name {
                font-weight: bold;
                color: #f5a742;
            }

            .stat-value {
                color: white;
            }

            /* ======================
            UPGRADE OPTIONS CONTAINER
            ====================== */
            .upgrade-options {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            /* ======================
            TITLE SCREEN
            ====================== */
            #titleScreen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: url('https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/background.svg') center/cover no-repeat;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                color: white;
                font-family: 'Arial', sans-serif;
                padding: 20px;
                box-sizing: border-box;
                overflow-y: auto;
                min-height: 100vh;
            }

            #titleScreen ~ #gameContainer #startButton {
                display: none;
                pointer-events: none;
            }

            #titleScreen h1 {
                font-size: 3.5rem;
                margin-bottom: 4rem;
                margin-top: 2rem;
                text-shadow: 0 0 20px rgba(255,255,255,0.8);
                background: linear-gradient(to right, #f5d742, #f5a742);
                -webkit-background-clip: text;
                background-clip: text;
                color: transparent;
                text-align: center;
                animation: titleGlow 2s ease-in-out infinite alternate;
            }

            @keyframes titleGlow {
                from { text-shadow: 0 0 20px rgba(255,255,255,0.8); }
                to { text-shadow: 0 0 30px rgba(255,255,255,1), 0 0 40px rgba(245,215,66,0.5); }
            }

            /* ======================
            MENU SECTIONS
            ====================== */
            .menu-section {
                background: rgba(0,0,0,0.7);
                padding: 1.5rem;
                border-radius: 15px;
                margin-bottom: 30px;
                width: 100%;
                max-width: 600px;
                box-sizing: border-box;
            }

            .menu-section:last-of-type {
                margin-bottom: 20px;
            }

            .maps-container {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin-top: 10px;
            }

            .menu-title {
                font-size: 1.5rem;
                margin-bottom: 1rem;
                color: #f5a742;
            }

            .menu-options {
                display: flex;
                justify-content: center;
                gap: 15px;
                flex-wrap: wrap;
            }

            [data-map] {
                width: 100%;
                margin: 0;
            }

            /* ======================
            MENU BUTTONS
            ====================== */
            .menu-btn {
                background: linear-gradient(135deg, #3498db, #2980b9);
                color: white;
                border: none;
                padding: 0.8rem 1.5rem;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s;
                font-size: 1rem;
            }

            .menu-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(52, 152, 219, 0.6);
            }

            .menu-btn.selected {
                background: linear-gradient(135deg, #f39c12, #e67e22);
                box-shadow: 0 0 15px rgba(243, 156, 18, 0.6);
            }

            .menu-btn.locked {
                background: linear-gradient(135deg, #555, #333);
                color: #999;
                cursor: not-allowed;
            }

            .start-btn {
                background: linear-gradient(135deg, #27ae60, #2ecc71);
                padding: 1rem 3rem;
                font-size: 1.2rem;
                margin-top: 1rem;
                margin-bottom: 1rem;
                width: 100%;
                max-width: 300px;
            }

            .start-btn:hover {
                box-shadow: 0 0 20px rgba(46, 204, 113, 0.7);
            }

            /* ======================
			MULTIPLAYER STYLES
			====================== */
			.multiplayer-btn {
				background: linear-gradient(135deg, #e74c3c, #c0392b);
				padding: 1.8rem 4.5rem;
				font-size: 1.5rem;
				margin-top: 1.5rem;
				margin-bottom: 3rem;
				width: 100%;
				max-width: 450px;
				box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
				min-height: 65px;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.multiplayer-btn:hover {
				box-shadow: 0 10px 30px rgba(231, 76, 60, 0.6);
				transform: translateY(-4px) scale(1.02);
			}

			#multiplayerMenu {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: url('https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/background.svg') center/cover no-repeat;
				display: none;
				flex-direction: column;
				justify-content: flex-start;
				align-items: center;
				z-index: 1001;
				color: white;
				font-family: 'Arial', sans-serif;
				padding: 3rem 1rem 2rem 1rem;
				box-sizing: border-box;
				overflow-y: auto;
				min-height: 100vh;
			}

			.multiplayer-title {
				font-size: 3.5rem;
				margin-bottom: 3rem;
				margin-top: 1rem;
				text-shadow: 0 0 20px rgba(255,255,255,0.8);
				background: linear-gradient(to right, #f5d742, #f5a742);
				-webkit-background-clip: text;
				background-clip: text;
				color: transparent;
				text-align: center;
				animation: titleGlow 2s ease-in-out infinite alternate;
			}

			.multiplayer-container {
				display: flex;
				width: 95%;
				max-width: 1400px;
				gap: 2.5rem;
				margin: 1.5rem 0 2rem 0;
				justify-content: center;
				align-items: flex-start;
			}

			.multiplayer-left, .multiplayer-right {
				flex: 1;
				display: flex;
				flex-direction: column;
				gap: 2rem;
				max-width: 600px;
			}

			.connection-status, .menu-section, .lobby-list, .player-list {
				background: rgba(0,0,0,0.85);
				padding: 2.5rem;
				border-radius: 20px;
				margin: 0;
				width: 100%;
				box-sizing: border-box;
				backdrop-filter: blur(10px);
				border: 2px solid rgba(245, 215, 66, 0.3);
				box-shadow: 0 8px 32px rgba(0,0,0,0.5);
				transition: all 0.3s ease;
			}

			.connection-status:hover, .lobby-list:hover, .player-list:hover {
				border-color: rgba(245, 215, 66, 0.6);
				box-shadow: 0 12px 40px rgba(0,0,0,0.7);
				transform: translateY(-2px);
			}

			.lobby-list {
				max-height: 300px;
				overflow-y: auto;
			}

			.input-group {
				margin: 2rem 0;
			}

			.input-group:first-child {
				margin-top: 1rem;
			}

			.input-group:last-child {
				margin-bottom: 1rem;
			}

			.input-group label {
				display: block;
				margin-bottom: 1rem;
				font-weight: bold;
				color: #f5a742;
				font-size: 1.1rem;
			}

			.input-group input {
				width: 100%;
				padding: 1.2rem;
				border: 2px solid rgba(245, 215, 66, 0.3);
				border-radius: 10px;
				font-size: 1rem;
				background: rgba(255,255,255,0.1);
				color: white;
				backdrop-filter: blur(5px);
				transition: all 0.3s ease;
				box-sizing: border-box;
				margin-bottom: 0.5rem;
			}

			.input-group input:focus {
				outline: none;
				border-color: rgba(245, 215, 66, 0.8);
				box-shadow: 0 0 15px rgba(245, 215, 66, 0.3);
			}

			.input-group input::placeholder {
				color: rgba(255,255,255,0.6);
			}

			.back-btn {
				background: linear-gradient(135deg, #95a5a6, #7f8c8d);
				padding: 1.2rem 3rem;
				font-size: 1.2rem;
				margin-top: 3rem;
				margin-bottom: 2rem;
				align-self: center;
				max-width: 350px;
				box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3);
				min-height: 55px;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.back-btn:hover {
				box-shadow: 0 8px 25px rgba(149, 165, 166, 0.5);
				transform: translateY(-3px) scale(1.05);
			}

            /* ======================
            TOWER BAR
            ====================== */
            #towerBar {
                position: absolute;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 15px;
                padding: 10px;
                background: rgba(0,0,0,0.7);
                border-radius: 12px;
                z-index: 50;
            }

            .tower-icon {
                width: 50px;
                height: 50px;
                cursor: pointer;
                transition: all 0.2s;
                border-radius: 8px;
                padding: 2px;
                background: rgba(0,0,0,0.3);
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .tower-icon:hover {
                transform: scale(1.1);
                background: rgba(255,255,255,0.2);
            }

            .tower-icon:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            /* ======================
            PLAYER INDICATORS
            ====================== */
            .player-indicator {
                position: absolute;
                top: 5px;
                right: 5px;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid #fff;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                color: white;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            }

            .player-1 {
                background: #3498db;
            }

            .player-2 {
                background: #e74c3c;
            }

            /* ======================
            CUSTOM ALERTS
            ====================== */
            .custom-alert {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(50, 50, 50, 0.95);
                border-radius: 15px;
                padding: 20px;
                z-index: 2000;
                color: white;
                text-align: center;
                box-shadow: 0 5px 25px rgba(0,0,0,0.5);
                max-width: 80%;
                width: 400px;
                border: 1px solid #444;
            }

            .custom-alert h3 {
                margin-top: 0;
                color: #f5a742;
            }

            .custom-alert-buttons {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin-top: 20px;
            }

            .custom-alert-btn {
                padding: 10px 25px;
                border-radius: 8px;
                border: none;
                cursor: pointer;
                font-weight: bold;
                transition: all 0.3s;
                font-size: 1rem;
            }

            .custom-alert-btn.retry {
                background: linear-gradient(135deg, #3498db, #2980b9);
                color: white;
            }

            .custom-alert-btn.exit {
                background: linear-gradient(135deg, #e74c3c, #c0392b);
                color: white;
            }

            .custom-alert-btn:hover {
                transform: scale(1.05);
                box-shadow: 0 0 10px rgba(255,255,255,0.3);
            }

            .custom-alert-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                z-index: 1999;
            }

            /* ======================
            MEDIA QUERIES
            ====================== */
            @media (max-width:700px) {
                #ui { 
                    font-size: 0.97em; 
                    padding: 7px 7px; 
                }
                
                #resources-left, #resources-right { 
                    gap: 10px; 
                }
                
                .resource { 
                    font-size: 0.98em; 
                }
                
                #towerMenu, #upgradeMenu { 
                    min-width: 130px; 
                }
                
                .tower-option, .upgrade-option { 
                    font-size: 12px; 
                    min-height: 52px; 
                }
                
                #towerBar { 
                    gap: 8px; 
                    padding: 5px; 
                }
                
                .tower-icon { 
                    width: 40px; 
                    height: 40px; 
                }
            }

            @media (max-width: 900px) {
                .multiplayer-container {
                    flex-direction: column;
                }
            }

            @media (max-width: 768px) {
                #titleScreen h1,
                .multiplayer-title {
                    font-size: 2.5rem;
                    margin-bottom: 1.5rem;
                }
                
                .maps-container {
                    grid-template-columns: repeat(2, 1fr);
                }
                
                .menu-options {
                    flex-direction: column;
                    gap: 10px;
                }
                
                .menu-btn {
                    padding: 0.6rem 1rem;
                    font-size: 0.9rem;
                }
                
                .start-btn, .multiplayer-btn {
                    padding: 0.8rem 2rem;
                    font-size: 1rem;
                }
            }

            @media (max-width: 500px) {
                #titleScreen h1,
                .multiplayer-title {
                    font-size: 2rem;
                }
                
                .menu-section {
                    width: 100%;
                    padding: 0.8rem;
                }
                
                .maps-container {
                    grid-template-columns: 1fr;
                }
                
                .menu-options {
                    flex-direction: column;
                    align-items: center;
                }
                
                .menu-btn {
                    width: 100%;
                    padding: 0.5rem;
                    font-size: 0.9rem;
                }
                
                .start-btn, .multiplayer-btn {
                    width: 100%;
                    padding: 0.7rem;
                    font-size: 0.9rem;
                }
            }
			 #chatContainer {
				position: fixed;
				bottom: 20px;
				right: 20px;
				width: 300px;
				background: rgba(0,0,0,0.8);
				border-radius: 10px;
				padding: 10px;
				z-index: 1000;
				display: none;
			}

			#chatMessages {
				height: 200px;
				overflow-y: auto;
				margin-bottom: 10px;
				color: white;
				font-family: Arial, sans-serif;
				font-size: 14px;
			}

			#chatInput {
				width: calc(100% - 60px);
				padding: 5px;
				border-radius: 5px;
				border: none;
			}

			#sendChat {
				width: 50px;
				padding: 5px;
				border-radius: 5px;
				border: none;
				background: #3498db;
				color: white;
				cursor: pointer;
			}

			#toggleChat {
				position: fixed;
				bottom: 20px;
				right: 20px;
				background: #3498db;
				color: white;
				border: none;
				border-radius: 50%;
				width: 40px;
				height: 40px;
				font-size: 20px;
				cursor: pointer;
				z-index: 1001;
				display: none;
			}
    </style>
</head>
<body>
    <!-- Title Screen -->
    <div id="titleScreen">
        <h1>Legion of Towers</h1>

        <div class="menu-section">
            <div class="menu-title">Difficulty</div>
            <div class="menu-options">
                <button class="menu-btn selected" data-difficulty="easy">Easy</button>
                <button class="menu-btn locked" data-difficulty="medium">Medium</button>
                <button class="menu-btn locked" data-difficulty="hard">Hard</button>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-title">Select Map</div>
            <div class="maps-container">
                <button class="menu-btn selected" data-map="1">Forest</button>
                <button class="menu-btn locked" data-map="2">Desert</button>
                <button class="menu-btn locked" data-map="3">Mountains</button>
                <button class="menu-btn locked" data-map="4">Canyon</button>
                <button class="menu-btn locked" data-map="5">Valley</button>
                <button class="menu-btn locked" data-map="6">Hexagon</button>
            </div>
        </div>

        <button class="menu-btn start-btn">Start Game</button>
        <button class="menu-btn multiplayer-btn">Multiplayer</button>
    </div>

    <!-- Multiplayer Menu -->
    <div id="multiplayerMenu">
        <h1 class="multiplayer-title">Multiplayer Menu</h1>
        
        <div class="multiplayer-container">
            <div class="multiplayer-left">
                <div class="connection-status">
					<label>Lobby Code:</label>
					<input type="text" id="lobbyCodeDisplay" readonly>
                    <h3>Connection Status</h3>
                    <div id="connectionStatus">Disconnected</div>
                </div>

                <div class="menu-section">
                    <div class="menu-title">Join Game</div>
                    <div class="input-group">
                        <label for="playerName">Your Name:</label>
                        <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
                    </div>
                    <div class="menu-options">
                        <button class="menu-btn" id="hostLobbyBtn">Host a Lobby</button>
                        <button class="menu-btn" id="joinRandomBtn">Join Random</button>
                    </div>
                    
                    <div class="input-group">
                        <label for="lobbyCode">Lobby Code:</label>
                        <input type="text" id="lobbyCode" placeholder="Enter lobby code to join">
                    </div>
                    <button class="menu-btn" id="joinLobbyBtn">Join Lobby</button>
                </div>
            </div>
            
            <div class="multiplayer-right">
                <div class="lobby-list">
                    <h3>Available Lobbies</h3>
                    <div id="lobbyListContainer">
                        <div class="lobby-item">No lobbies available</div>
                    </div>
                </div>

                <div class="player-list">
                    <h3>Connected Players</h3>
                    <div id="playerListContainer">
                        <div class="player-item">
                            <span>No players connected</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="menu-section" id="hostControls" style="display: none;">
            <div class="menu-title">Host Controls</div>
            <button class="menu-btn start-btn" id="startMultiplayerGame">Start Multiplayer Game</button>
        </div>

        <button class="menu-btn back-btn" id="backToMainBtn">Back to Main Menu</button>
    </div>

    <!-- Game Container -->
    <div id="gameContainer">
        <div id="ui">
            <div id="resources-left">
                <div class="resource life">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/lifes.svg" width="25" height="25">
                    <span id="lifeAmount">20/20</span>
                </div>
                <div class="resource gold">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/gold.svg" width="25" height="25">
                    <span id="goldAmount">20000</span>
                </div>
                <div class="resource bluecrystal">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/dia.svg" width="25" height="25">
                    <span id="crystalAmount">5</span>
                </div>
            </div>
            <div id="resources-right">
                <div class="resource wave">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/wave.svg" width="25" height="25">
                    <span id="waveNumber">1/5</span>
                </div>
                <div class="resource enemies">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/enemy.svg" width="25" height="25">
                    <span id="enemiesKilled">0/10</span>
                </div>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="towerBar">
            <!-- Tower icons will be added here dynamically -->
        </div>
        <div id="towerMenu"></div>
        <div id="upgradeMenu"></div>
        <button id="startButton">Next Wave</button>

        <div id="playerIndicators" style="display:none; position:absolute; top:10px; right:10px; z-index:1000; background:rgba(0,0,0,0.7); padding:8px; border-radius:8px; color:white;">
            <div>Player <span id="playerNumber">1</span></div>
            <div>Connected: <span id="connectedPlayers">1/2</span></div>
        </div>
    </div>
	
	<button id="toggleChat">💬</button>
    <div id="chatContainer">
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Type a message...">
        <button id="sendChat">Send</button>
    </div>

<script>
    // ======================
    // MULTIPLAYER SYSTEM
    // ======================
    class MultiplayerManager {
        constructor() {
            this.isHost = false;
            this.isConnected = false;
            this.playerName = '';
            this.lobbyCode = '';
            this.connection = null;
            this.connectedPlayers = new Map();
            this.availableLobbies = [];
            this.playerRole = null;
            this.peer = null;
            this.connections = new Map();
            
            this.setupEventListeners();
            this.updateUI();
        }

        setupEventListeners() {
            document.getElementById('hostLobbyBtn').addEventListener('click', () => this.hostLobby());
            document.getElementById('joinRandomBtn').addEventListener('click', () => this.joinRandomLobby());
            document.getElementById('joinLobbyBtn').addEventListener('click', () => this.joinLobby());
            document.getElementById('backToMainBtn').addEventListener('click', () => this.backToMain());
            document.getElementById('startMultiplayerGame').addEventListener('click', () => this.startGame());
            
            // Chat controls
            document.getElementById('toggleChat').addEventListener('click', () => {
                const chat = document.getElementById('chatContainer');
                chat.style.display = chat.style.display === 'none' ? 'block' : 'none';
            });
            
            document.getElementById('sendChat').addEventListener('click', () => this.sendChatMessage());
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.sendChatMessage();
            });
        }
		
		async initializePeerJS() {
            // Create a new Peer
            this.peer = new Peer();
            
            return new Promise((resolve, reject) => {
                this.peer.on('open', (id) => {
                    console.log('PeerJS connected with ID:', id);
                    resolve(id);
                });
                
                this.peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    reject(err);
                });
            });
        }

        // Änderung in der hostLobby-Methode
		async hostLobby() {
			const playerName = document.getElementById('playerName').value.trim();
			if (!playerName) {
				this.showCustomAlert('Please enter your name first!');
				return;
			}

                        try {
                                if (this.peer) {
                                        this.peer.destroy();
                                }

                                this.peer = new Peer({
                                        debug: 3,
                                        config: {
                                                iceServers: [
                                                        { urls: 'stun:stun.l.google.com:19302' },
                                                        { urls: 'stun:stun1.l.google.com:19302' }
						]
					}
				});

				const peerId = await new Promise((resolve, reject) => {
					this.peer.on('open', resolve);
					this.peer.on('error', reject);
					setTimeout(() => reject('PeerJS initialization timeout'), 15000);
				});

				// Store the full peer ID
                                this.lobbyCode = peerId;
                                this.playerName = playerName;
                                this.playerRole = 'host';

                                // Ensure the local player list always starts clean
                                this.connections.clear();
                                this.connectedPlayers.clear();
                                this.connectedPlayers.set(this.peer.id, {
                                        id: this.peer.id,
                                        name: this.playerName,
                                        role: 'host',
                                        status: 'connected'
                                });
				
				// Update UI - MAKE SURE THIS ELEMENT EXISTS
				const lobbyDisplay = document.getElementById('lobbyCodeDisplay');
				if (lobbyDisplay) {
					lobbyDisplay.value = peerId;
				} else {
					console.error('lobbyCodeDisplay element not found!');
					// Fallback: Show alert with the code
					this.showCustomAlert(`Lobby created! Code: ${peerId}`);
				}

				// Set up connection handler
                                this.peer.on('connection', (conn) => {
                                        console.log('Incoming connection:', conn.peer);
                                        this.setupConnection(conn);
                                });

                                this.isHost = true;
                                this.isConnected = true;
                                this.updateUI();

                                // Allow the host to access the chat immediately
                                document.getElementById('toggleChat').style.display = 'block';

                        } catch (error) {
				console.error('Failed to host lobby:', error);
				if (this.peer) this.peer.destroy();
				this.showCustomAlert(`Failed to create lobby: ${error}`);
			}
		}
		
		lobbyCodeToPeerId(lobbyCode) {
            // Since we create lobby codes from the first 6 characters of peer ID,
            // we need the full peer ID to connect. In a real implementation,
            // you'd have a server to map codes to full peer IDs.
            // For this demo, we'll assume the full peer ID is available
            // This is a limitation of the current implementation
            return lobbyCode.trim();
        }

        setupConnection(conn) {
            conn.on('open', () => {
                console.log('Connection established with:', conn.peer);
                
                // Add to connections map
                this.connections.set(conn.peer, conn);
                
                // Send welcome message with our info
                this.sendMessageToConnection(conn, {
                    type: 'playerInfo',
                    peerId: this.peer.id,
                    playerName: this.playerName,
                    role: this.playerRole
                });
                
                // Update player list if we're host
                if (this.isHost) {
                    this.connectedPlayers.set(conn.peer, {
                        id: conn.peer,
                        name: conn.metadata?.playerName || 'Guest',
                        role: 'guest',
                        status: 'connected'
                    });
                    this.updatePlayerList();
                }
            });
            
            // Handle incoming messages
            conn.on('data', (data) => this.handleMessage(data, conn.peer));
            
            conn.on('close', () => {
                console.log('Connection closed with:', conn.peer);
                this.connections.delete(conn.peer);
                this.connectedPlayers.delete(conn.peer);
                this.updatePlayerList();
            });
            
            conn.on('error', (err) => {
                console.error('Connection error with', conn.peer, ':', err);
            });
        }
		
        findHostPeerId(lobbyCode) {
            // In a real implementation, you'd look up the peer ID from the lobby code
            // For this demo, we'll just use the lobby code directly (since we're not using a server)
            return lobbyCode.trim();
        }

        joinRandomLobby() {
            alert('Random lobby joining is not implemented in this demo. Please use a specific lobby code.');
        }

        async joinLobby() {
            const playerName = document.getElementById('playerName').value.trim();
            const lobbyCodeInput = document.getElementById('lobbyCode').value.trim();

            if (!playerName) {
                this.showCustomAlert('Please enter your name first!');
                return;
            }

            if (!lobbyCodeInput) {
                this.showCustomAlert('Please enter a lobby code!');
                return;
            }

            try {
                console.log('Joining lobby with code:', lobbyCodeInput);
                
                // Check if PeerJS is available
                if (typeof Peer === 'undefined') {
                    throw new Error('PeerJS library not loaded. Please check your internet connection.');
                }

                // Initialize PeerJS
                this.peer = new Peer({
					debug: 3, // Increased verbosity
					config: {
						iceServers: [
							{ urls: 'stun:stun.l.google.com:19302' },
							{ urls: 'stun:stun1.l.google.com:19302' },
							{ urls: 'stun:stun2.l.google.com:19302' }
						]
					},
					iceTransportPolicy: 'all'
				});

                const peerId = await new Promise((resolve, reject) => {
                    let resolved = false;
                    
                    this.peer.on('open', (id) => {
                        if (!resolved) {
                            resolved = true;
                            resolve(id);
                        }
                    });
                    
                    this.peer.on('error', (err) => {
                        if (!resolved) {
                            resolved = true;
                            reject(err);
                        }
                    });
                    
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('Connection timeout'));
                        }
                    }, 15000);
                });

                this.playerName = playerName;
                this.isHost = false;
                this.playerRole = 'guest';

                // Convert lobby code back to host peer ID
                //const hostPeerId = this.lobbyCodeToPeerId(lobbyCode);
                                const hostPeerId = lobbyCodeInput; // Expect full ID
                                console.log("Connecting to:", hostPeerId); // Debug log

                // Connect to host
                const conn = this.peer.connect(hostPeerId, {
                    reliable: true,
                    metadata: {
                        playerName: playerName,
                        role: 'guest'
                    }
                });

                // Setup connection
                await new Promise((resolve, reject) => {
                    let resolved = false;
                    
                    conn.on('open', () => {
                        if (!resolved) {
                            resolved = true;
                            console.log('Connected to host successfully');
                            this.setupConnection(conn);
                            resolve();
                        }
                    });
                    
                    conn.on('error', (err) => {
						if (!resolved) {
							resolved = true;
							console.error('Connection error:', err);
							reject(new Error('Failed to connect to lobby. Please check the code and try again.'));
							this.showCustomAlert('Connection failed. Please check the lobby code and try again.', 'Error');
						}
					});
                    
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('Connection timeout. Host might be offline.'));
                        }
                    }, 10000);
                });

                // Add self to player list
                this.connectedPlayers.set(peerId, {
                    id: peerId,
                    name: playerName,
                    role: 'guest',
                    status: 'connected'
                });

                this.lobbyCode = hostPeerId;
                this.isConnected = true;
                this.updateUI();
                this.showCustomAlert(`Successfully joined lobby: ${hostPeerId}`, 'Success');
                
                // Show chat controls
                document.getElementById('toggleChat').style.display = 'block';
                
            } catch (error) {
                console.error('Failed to join lobby:', error);
                this.showCustomAlert(`Failed to join lobby: ${error.message}`, 'Error');
                
                // Cleanup on error
                if (this.peer) {
                    this.peer.destroy();
                    this.peer = null;
                }
                this.isConnected = false;
                this.updateUI();
            }
        }

        joinSpecificLobby(lobbyCode, playerName) {
            this.playerName = playerName;
            this.lobbyCode = lobbyCode;
            this.isHost = false;
            this.isConnected = true;
            this.playerRole = 'guest';

            // Simulate joining
            this.connectedPlayers.set('guest', {
                name: playerName,
                role: 'guest',
                status: 'connected'
            });

            // Simulate host already being there
            this.connectedPlayers.set('host', {
                name: 'Host Player',
                role: 'host',
                status: 'connected'
            });

            this.updateUI();
            alert(`Joined lobby: ${lobbyCode}`);
        }

        backToMain() {
            // Cleanup connections
            if (this.peer) {
                this.peer.destroy();
                this.peer = null;
            }
            
            this.connections.clear();
            this.connectedPlayers.clear();
            
            // Reset state
            this.isHost = false;
            this.isConnected = false;
            this.lobbyCode = '';
            this.playerRole = null;
            
            // Hide UI elements
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('titleScreen').style.display = 'flex';
            document.getElementById('toggleChat').style.display = 'none';
            
            this.updateUI();
        }

        updateLobbyList() {
            const container = document.getElementById('lobbyListContainer');
            
            if (this.availableLobbies.length === 0) {
                container.innerHTML = '<div class="lobby-item">No lobbies available</div>';
                return;
            }

            container.innerHTML = '';
            this.availableLobbies.forEach(lobby => {
                const item = document.createElement('div');
                item.className = 'lobby-item';
                item.innerHTML = `
                    <div>Code: ${lobby.code}</div>
                    <div>Host: ${lobby.host}</div>
                    <div>Players: ${lobby.players}/${lobby.maxPlayers}</div>
                `;
                item.addEventListener('click', () => {
                    document.getElementById('lobbyCode').value = lobby.code;
                });
                container.appendChild(item);
            });
        }

        updatePlayerList() {
            const container = document.getElementById('playerListContainer');
            
            if (this.connectedPlayers.size === 0) {
                container.innerHTML = '<div class="player-item"><span>No players connected</span></div>';
                return;
            }

            container.innerHTML = '';
            this.connectedPlayers.forEach((player) => {
                const item = document.createElement('div');
                item.className = 'player-item';
                
                item.innerHTML = `
                    <span>${player.name}</span>
                    <span class="player-status">
                        ${player.role === 'host' ? 'Host' : 'Guest'}
                    </span>
                `;
                container.appendChild(item);
            });
        }

        updateUI() {
            // Update connection status
            const statusEl = document.getElementById('connectionStatus');
            if (this.isConnected) {
                statusEl.textContent = `Connected - ${this.isHost ? 'Hosting' : 'Guest'} - Code: ${this.lobbyCode}`;
                statusEl.style.color = '#27ae60';
            } else {
                statusEl.textContent = 'Disconnected';
                statusEl.style.color = '#e74c3c';
            }

            // Update player list
            this.updatePlayerList();

            // Show/hide host controls
            const hostControls = document.getElementById('hostControls');
            if (this.isHost && this.isConnected) {
                hostControls.style.display = 'block';
            } else {
                hostControls.style.display = 'none';
            }
        }

        // Network message handling (simplified for demo)
        sendMessage(type, data) {
            // In a real implementation, this would send over WebRTC
            console.log('Sending message:', { type, data });
            
            // Simulate receiving the message for demo
            setTimeout(() => {
                this.handleMessage({ type, data, fromPlayer: this.playerRole === 'host' ? 'guest' : 'host' });
            }, 100);
        }
		
		sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;
            
            // Display locally
            this.displayChatMessage(this.playerName, message);
            
            // Broadcast to others
            this.broadcastMessage({
                type: 'chat',
                sender: this.playerName,
                message: message
            });
            
            input.value = '';
        }
		
		sendMessageToConnection(conn, message) {
            try {
                if (conn && conn.open) {
                    conn.send(message);
                } else {
                    console.warn('Attempted to send message to closed connection');
                }
            } catch (error) {
                console.error('Failed to send message:', error);
            }
        }

        broadcastMessage(message, excludePeerId = null) {
            this.connections.forEach((conn, peerId) => {
                if (peerId !== excludePeerId && conn.open) {
                    this.sendMessageToConnection(conn, message);
                }
            });
        }
		
		displayChatMessage(sender, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        handleMessage(message, fromPeer) {
            console.log('Received message from', fromPeer, ':', message);
            
            switch (message.type) {
                case 'playerInfo':
                    // Update player info
                    this.connectedPlayers.set(message.peerId, {
                        id: message.peerId,
                        name: message.playerName,
                        role: message.role,
                        status: 'connected'
                    });
                    this.updatePlayerList();
                    break;
                    
                case 'chat':
                    this.displayChatMessage(message.sender, message.message);
                    break;
                    
                case 'towerPlaced':
                    this.handleTowerPlaced(message.data);
                    break;
                    
                case 'towerUpgraded':
                    this.handleTowerUpgraded(message.data);
                    break;
                    
                case 'waveStarted':
                    this.handleWaveStarted(message.data);
                    break;
                    
                case 'gameState':
                    this.handleGameStateUpdate(message.data);
                    break;
                case 'gameStart':
                    // Hide menus for guest
                    document.getElementById('multiplayerMenu').style.display = 'none';
                    document.getElementById('titleScreen').style.display = 'none';
                    document.getElementById('startButton').style.display = 'block';
                    document.getElementById('startButton').style.pointerEvents = 'auto';
                    
                    // Sync game settings
                    gameConfig.isMultiplayer = true;
                    gameConfig.playerRole = 'guest';
                    gameConfig.map = data.map;
                    gameConfig.difficulty = data.difficulty;
                    
                    // Sync game state
                    gameState.wave = data.wave;
                    gameState.gold = data.gold;
                    
                    // Start game for guest
                    initGame();
                    mainLoop();
                    break;
            }
        }
		
		// JavaScript für benutzerdefinierte Alerts
		showCustomAlert(message, title = 'Alert') {
            const overlay = document.createElement('div');
            overlay.className = 'custom-alert-overlay';
            
            const alertBox = document.createElement('div');
            alertBox.className = 'custom-alert';
            alertBox.innerHTML = `
                <h3>${title}</h3>
                <p>${message}</p>
                <div class="custom-alert-buttons">
                    <button class="custom-alert-btn retry">OK</button>
                </div>
            `;
            
            const okBtn = alertBox.querySelector('.retry');
            okBtn.addEventListener('click', () => {
                document.body.removeChild(overlay);
                document.body.removeChild(alertBox);
            });
            
            document.body.appendChild(overlay);
            document.body.appendChild(alertBox);
        }

        handleTowerPlaced(data) {
            // Add tower placed by other player
            const tower = {
                x: data.x,
                y: data.y,
                type: {...data.type},
                lastShot: 0,
                level: 1,
                upgrades: {
                    dmg: 0,
                    rate: 0,
                    range: 0,
                    slow: 0,
                    special: data.type.upgrades.special ? 
                        {...data.type.upgrades.special, purchased: false} : null
                },
                flameWidth: data.type.bulletType === "flame" ? 10 : 0,
                lastFreeze: 0,
                placedBy: data.playerId
            };
            
            towers.push(tower);
        }

        handleTowerUpgraded(data) {
            // Find and upgrade tower
            const tower = towers.find(t => t.x === data.x && t.y === data.y);
            if (tower) {
                Object.assign(tower.upgrades, data.upgrades);
                tower.level = data.level;
            }
        }

        handleWaveStarted(data) {
            if (!gameState.waveActive) {
                startWave();
            }
        }

        handleGameStateUpdate(data) {
            // Sync shared game state (lives, wave number, etc.)
            if (data.lives !== undefined) gameState.lives = data.lives;
            if (data.wave !== undefined) gameState.wave = data.wave;
            updateUI();
        }

        startGame() {
            if (!this.isHost) {
                this.showCustomAlert('Only the host can start the game!');
                return;
            }

            // Count only connected guests (excluding host)
            const connectedPlayers = [...this.connectedPlayers.values()].filter(p => p.role === 'guest');
            
            if (connectedPlayers.length < 1) {
                this.showCustomAlert('Need at least 1 other player to start!');
                return;
            }

            // Hide menus and show game UI for host
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('startButton').style.pointerEvents = 'auto';
            
            // Initialize multiplayer game
            gameConfig.isMultiplayer = true;
            gameConfig.playerRole = this.playerRole;
            gameConfig.connectedPlayers = this.connectedPlayers;
            
            // Broadcast game start to all players
            this.broadcastMessage({
                type: 'gameStart',
                wave: gameState.wave,
                gold: gameState.gold,
                map: gameConfig.map,
                difficulty: gameConfig.difficulty
            });

            // Start game for host
            initGame();
            mainLoop();
        }

        // Send multiplayer game events
        sendMessage(type, data) {
            this.broadcastMessage({
                type: type,
                data: data,
                timestamp: Date.now()
            });
        }    
    }

    // Create multiplayer manager instance
    const multiplayerManager = new MultiplayerManager();

    // ======================
    // GAME CONFIGURATION
    // ======================
    let gameConfig = {
        difficulty: 'easy',
        map: 1,
        unlockedMaps: [1, 2, 3, 4, 5, 6],
        unlockedDifficulties: ['easy'],
        isMultiplayer: false,
        playerRole: null,
        connectedPlayers: null,
        difficulties: {
            easy: { gold: 300, enemyHpMultiplier: 2.0 },
            medium: { gold: 200, enemyHpMultiplier: 3.5 },
            hard: { gold: 150, enemyHpMultiplier: 5.0 }
        }
    };

    // Enemy tier system - T1 (green) to T5 (black)
    const enemyTiers = [
        {   // T1 - Green (weakest)
            name: "T1 Grunt",
            color: "#4CAF50",
            hp: 50,
            speed: 1.4,
            goldValue: 10,
            tier: 1
        },
        {   // T2 - Blue
            name: "T2 Soldier",
            color: "#2196F3",
            hp: 120,
            speed: 1.1,
            goldValue: 20,
            tier: 2
        },
        {   // T3 - Purple
            name: "T3 Elite",
            color: "#9C27B0",
            hp: 250,
            speed: 0.9,
            goldValue: 35,
            tier: 3
        },
        {   // T4 - Red
            name: "T4 Champion",
            color: "#F44336",
            hp: 450,
            speed: 0.7,
            goldValue: 55,
            tier: 4
        },
        {   // T5 - Black (strongest)
            name: "T5 Boss",
            color: "#212121",
            hp: 800,
            speed: 0.5,
            goldValue: 80,
            tier: 5
        }
    ];

    // ======================
    // MENU EVENT LISTENERS
    // ======================
    
    // Multiplayer button event listener
    document.querySelector('.multiplayer-btn').addEventListener('click', function() {
        document.getElementById('titleScreen').style.display = 'none';
        document.getElementById('multiplayerMenu').style.display = 'flex';
    });

    // Title screen logic (difficulty and map selection)
    document.querySelectorAll('[data-difficulty]').forEach(btn => {
        btn.addEventListener('click', function() {
            if (this.classList.contains('locked')) return;
            document.querySelectorAll('[data-difficulty]').forEach(b => b.classList.remove('selected'));
            this.classList.add('selected');
            gameConfig.difficulty = this.dataset.difficulty;
        });
    });

    document.querySelectorAll('[data-map]').forEach(btn => {
        btn.addEventListener('click', function() {
            const mapNum = parseInt(this.dataset.map);
            if (this.classList.contains('locked') || !gameConfig.unlockedMaps.includes(mapNum)) return;
            
            document.querySelectorAll('[data-map]').forEach(b => b.classList.remove('selected'));
            this.classList.add('selected');
            gameConfig.map = mapNum;
        });
    });

    // Main game loop function
    function mainLoop() {
        update();
        draw();
        requestAnimationFrame(mainLoop);
    }

    // Update function to handle game logic
    document.querySelector('.start-btn').addEventListener('click', function() {
        document.getElementById('titleScreen').style.display = 'none';
        document.getElementById('startButton').style.display = 'block';
        document.getElementById('startButton').style.pointerEvents = 'auto';
        initGame();
        mainLoop(); // Now this will work
    });

    // Window resize handler
    window.addEventListener('resize', function() {
        if (document.getElementById('titleScreen').style.display === 'none') {
            resizeCanvas();
        }
    });

    // Initialize the game with selected settings
    async function initGame() {
        const difficulty = gameConfig.difficulties[gameConfig.difficulty];
        gameState.gold = difficulty.gold;

        document.body.classList.remove('in-title-screen');

        // Select map based on choice
        switch(gameConfig.map) {
            case 1: setupMap1(); break;
            case 2: setupMap2(); break;
            case 3: setupMap3(); break;
            case 4: setupMap4(); break;
            case 5: setupMap5(); break;
            case 6: setupMap6(); break;
        }

        if (gameConfig.isMultiplayer) {
            // Show player indicators
            document.getElementById('playerIndicators').style.display = 'block';
            
            // Host is player 1, guest is player 2
            if (gameConfig.playerRole === 'host') {
                gameState.playerNumber = 1;
            } else {
                gameState.playerNumber = 2;
            }
        }

        // Initialize tower bar
        setupTowerBar();

        updateUI();
        resizeCanvas(); // Important for correct display

        try {
            await preloadTowerIcons();
            console.log("All tower icons loaded");
        } catch (error) {
            console.error("Failed to load tower icons:", error);
            // Fallback: will use colored rectangles instead of icons
        }
    }

    // Path variable that will be used by all map functions
    let path = [];

    function setupMap1() {
        // Scale coordinates to fit game canvas
        const scaleX = GAME_WIDTH / 1600;
        const scaleY = GAME_HEIGHT / 900;
        
        path = [
            {x: 100 * scaleX, y: 200 * scaleY}, 
            {x: 600 * scaleX, y: 200 * scaleY}, 
            {x: 600 * scaleX, y: 400 * scaleY}, 
            {x: 400 * scaleX, y: 400 * scaleY},
            {x: 400 * scaleX, y: 600 * scaleY}, 
            {x: 800 * scaleX, y: 600 * scaleY},
            {x: 800 * scaleX, y: 350 * scaleY}, 
            {x: 1200 * scaleX, y: 350 * scaleY},
            {x: 1200 * scaleX, y: 750 * scaleY}, 
            {x: 1500 * scaleX, y: 750 * scaleY}
        ];
        generateMapElements();
    }

    function setupMap2() {
        const scaleX = GAME_WIDTH / 1600;
        const scaleY = GAME_HEIGHT / 900;
        
        path = [
            {x: 100 * scaleX, y: 450 * scaleY}, 
            {x: 100 * scaleX, y: 150 * scaleY}, 
            {x: 700 * scaleX, y: 150 * scaleY}, 
            {x: 700 * scaleX, y: 350 * scaleY},
            {x: 300 * scaleX, y: 350 * scaleY}, 
            {x: 300 * scaleX, y: 650 * scaleY},
            {x: 1100 * scaleX, y: 650 * scaleY}, 
            {x: 1100 * scaleX, y: 250 * scaleY},
            {x: 500 * scaleX, y: 250 * scaleY}, 
            {x: 500 * scaleX, y: 750 * scaleY},
            {x: 1500 * scaleX, y: 750 * scaleY}
        ];
        generateMapElements();
    }

    function setupMap3() {
        const scaleX = GAME_WIDTH / 1600;
        const scaleY = GAME_HEIGHT / 900;
        
        path = [
            {x: 50 * scaleX, y: 850 * scaleY}, 
            {x: 300 * scaleX, y: 600 * scaleY},
            {x: 550 * scaleX, y: 850 * scaleY}, 
            {x: 800 * scaleX, y: 600 * scaleY},
            {x: 1050 * scaleX, y: 850 * scaleY}, 
            {x: 1300 * scaleX, y: 600 * scaleY},
            {x: 1550 * scaleX, y: 850 * scaleY}
        ];
        generateMapElements();
    }

    function setupMap4() {
        const scaleX = GAME_WIDTH / 400;  // Map4 has different dimensions (400x400)
        const scaleY = GAME_HEIGHT / 400;
        
        path = [
            {x: 20 * scaleX, y: 200 * scaleY}, 
            {x: 200 * scaleX, y: 200 * scaleY},
            {x: 200 * scaleX, y: 50 * scaleY}, 
            {x: 350 * scaleX, y: 50 * scaleY},
            {x: 350 * scaleX, y: 150 * scaleY}, 
            {x: 100 * scaleX, y: 150 * scaleY},
            {x: 100 * scaleX, y: 250 * scaleY}, 
            {x: 300 * scaleX, y: 250 * scaleY},
            {x: 300 * scaleX, y: 100 * scaleY}, 
            {x: 150 * scaleX, y: 100 * scaleY},
            {x: 150 * scaleX, y: 300 * scaleY}, 
            {x: 380 * scaleX, y: 300 * scaleY}
        ];
        generateMapElements();
    }

    function setupMap5() {
        const scaleX = GAME_WIDTH / 1600;
        const scaleY = GAME_HEIGHT / 900;
        
        path = [
            {x: 50 * scaleX, y: 100 * scaleY}, 
            {x: 550 * scaleX, y: 100 * scaleY},
            {x: 550 * scaleX, y: 300 * scaleY}, 
            {x: 1050 * scaleX, y: 300 * scaleY},
            {x: 1050 * scaleX, y: 500 * scaleY}, 
            {x: 1550 * scaleX, y: 500 * scaleY}
        ];
        generateMapElements();
    }

    function setupMap6() {
        const scaleX = GAME_WIDTH / 1600;
        const scaleY = GAME_HEIGHT / 900;
        
        path = [
            {x: 800 * scaleX, y: 100 * scaleY}, 
            {x: 1100 * scaleX, y: 100 * scaleY},
            {x: 1400 * scaleX, y: 450 * scaleY}, 
            {x: 1100 * scaleX, y: 800 * scaleY},
            {x: 800 * scaleX, y: 800 * scaleY}, 
            {x: 500 * scaleX, y: 450 * scaleY},
            {x: 800 * scaleX, y: 100 * scaleY}
        ];
        generateMapElements();
    }

    // Canvas and UI elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const towerMenu = document.getElementById('towerMenu');
    const upgradeMenu = document.getElementById('upgradeMenu');
    const startButton = document.getElementById('startButton');
    const towerBar = document.getElementById('towerBar');

    // Game variables
    let mapElements = [];
    const LIFE_MAX = 20;
    const MAX_WAVE = 5;
    let enemiesPerWave = 10;
    let selectedTower = null;
    let draggingTower = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    // Game state
    let gameState = {
        gold: 200000,
        crystals: 5,
        lives: LIFE_MAX,
        wave: 1,
        enemiesInWave: 0,
        enemiesLeft: 0,
        enemiesKilled: 0,
        enemiesTotal: 0,
        waveActive: false,
        nextWaveEnemies: 10
    };

    // UI elements
    const goldEl = document.getElementById('goldAmount');
    const crystalEl = document.getElementById('crystalAmount');
    const lifeEl = document.getElementById('lifeAmount');
    const waveNumEl = document.getElementById('waveNumber');
    const enemiesKilledEl = document.getElementById('enemiesKilled');

    const towerIcons = {
        archer: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><defs><linearGradient id="arch1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#004d00"/><stop offset="100%" stop-color="#6f6"/></linearGradient><marker id="arch2" markerUnits="strokeWidth" markerWidth="4" markerHeight="4" refX="0" refY="2" orient="auto"><path d="m0 0 4 2-4 2Z" fill="#888"/></marker></defs><rect x="10" y="10" width="80" height="80" fill="url(#arch1)" stroke="#000" stroke-width="4" rx="16" ry="16"/><g fill="none" stroke="brown" stroke-width="4" stroke-linecap="round"><path d="M35 25v50M35 25a25 25 0 0 1 0 50" transform="matrix(.85 0 0 .85 3.25 7.5)"/><path stroke="#888" marker-end="url(#arch2)" d="M35 50h40" transform="matrix(.85 0 0 .85 3.25 7.5)"/></g></svg>`,
        cannon: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><defs><linearGradient id="canon1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#666"/><stop offset="100%" stop-color="#aaa"/></linearGradient></defs><rect x="10" y="10" width="80" height="80" fill="url(#canon1)" stroke="#000" stroke-width="4" rx="16" ry="16"/><circle cx="50" cy="55" r="20" fill="#111" stroke="#000" stroke-width="3"/><path stroke="#fc0" stroke-width="3" stroke-linecap="round" d="M50 35V25"/><path d="m50 23-3-3 2 5 5-2-4 2Z" fill="#fd4"/></svg>`,
        mage: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><defs><linearGradient id="mage1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="indigo"/><stop offset="100%" stop-color="#9370db"/></linearGradient><linearGradient id="mage2" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#ddd"/><stop offset="100%" stop-color="#888"/></linearGradient><radialGradient id="mage3" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="#a0eaff"/><stop offset="100%" stop-color="#005fbb"/></radialGradient></defs><rect x="10" y="10" width="80" height="80" fill="url(#mage1)" stroke="#000" stroke-width="4" rx="16" ry="16"/><g transform="rotate(20 50 50)" stroke-linecap="round" stroke-linejoin="round"><path stroke="#ccc" stroke-width="3" d="M50 45v30m-5-20h10"/><path d="M48 45h4l2-5h-8Z" fill="url(#mage2)" stroke="#777"/><circle cx="50" cy="35" r="10" fill="url(#mage3)" stroke="#003f7f"/><path d="M50 25c10 0 15 10 7 15m-7-15c-10 0-15 10-7 15" stroke="#a0eaff" stroke-width="2" fill="none"/><path stroke="#a0eaff" stroke-width="2" d="m43 40-4 6"/><circle cx="38" cy="48" r="2" fill="#00ace6" stroke="#005fbb"/><path stroke="#a0eaff" stroke-width="2" d="m57 40 4 6"/><circle cx="62" cy="48" r="2" fill="#00ace6" stroke="#005fbb"/></g></svg>`,
        fire: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><defs><linearGradient id="fire1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="red"/><stop offset="100%" stop-color="orange"/></linearGradient><symbol id="b" viewBox="0 0 432 640"><g transform="matrix(.85 0 0 .85 -31.35 48)"/><path d="M165.214 571.337c4.185 2.224 8.599-2.593 6.037-6.58-13.906-21.644-27.075-58.063-6.094-104.967 34.987-78.216 56.277-118.726 56.277-118.726s11.324 47.275 42.02 89.31c29.544 40.454 45.714 91.334 19.645 133.72-2.447 3.978 1.867 8.671 6.025 6.544 32.27-16.508 68.464-49.62 72.548-115.512 1.505-20.135-.753-48.324-12.044-83.896-14.52-45.084-32.368-66.121-42.695-75.155-3.089-2.703-7.893-.308-7.64 3.789 3.01 48.646-15.291 60.99-25.708 33.17-4.16-11.112-6.586-30.33-6.586-53.736 0-38.966-11.305-79.077-36.229-111.672-6.48-8.476-14.065-16.397-22.766-23.15-3.15-2.447-7.716.012-7.427 3.99 1.913 26.414.18 102.119-66.237 192.561-60.22 83.896-36.885 148.328-28.605 165.779 15.831 33.43 37.913 53.064 59.479 64.53z" fill="#ff0" fill-rule="evenodd" stroke="#000" stroke-width="2.1"/></symbol></defs><rect x="10" y="10" width="80" height="80" fill="url(#fire1)" stroke="#000" stroke-width="4" rx="16" ry="16"/><svg x="10" y="10" width="80" height="80" viewBox="0 0 432 640"><use href="#b"/></svg></svg>`,
        ice: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><defs><linearGradient id="ice1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#007acc"/><stop offset="100%" stop-color="#a0e1ff"/></linearGradient><marker id="ice1" markerUnits="strokeWidth" markerWidth="4" markerHeight="4" refX="2" refY="2" orient="auto"><path d="M2 0v4" stroke="#fff"/></marker></defs><rect x="10" y="10" width="80" height="80" fill="url(#ice1)" stroke="#000" stroke-width="4" rx="16" ry="16"/><g stroke="#fff" stroke-width="2" stroke-linecap="round" marker-end="url(#ice1)"><path d="M50 20v60"/><path d="M20 50h60"/><path d="m30 30 40 40"/><path d="m30 70 40-40"/><path d="m50 30-5-5"/><path d="m50 30 5-5"/><path d="m50 70-5 5"/><path d="m50 70 5 5"/><path d="m70 50 5-5"/><path d="m70 50 5 5"/><path d="m30 50-5-5"/><path d="m30 50-5 5"/><path d="m60 60 5 5"/><path d="m60 60-5 5"/><path d="m40 40-5-5"/><path d="m40 40 5-5"/><path d="m60 40 5-5"/><path d="m60 40 5 5"/><path d="m40 60-5-5"/><path d="m40 60-5 5"/></g></svg>`,
        sniper: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><defs><linearGradient id="snipe1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#333"/><stop offset="100%" stop-color="#001f3f"/></linearGradient></defs><rect x="10" y="10" width="80" height="80" fill="url(#snipe1)" stroke="#000" stroke-width="4" rx="16" ry="16"/><g fill="none" stroke="#aaa" stroke-width="3"><circle cx="50" cy="50" r="20"/><circle cx="50" cy="50" r="10" stroke-width="2"/><path d="M50 30v40M30 50h40"/><path stroke-width="2" d="M50 18v6m0 52v6M18 50h6m52 0h6"/></g></svg>`
    };

    // Tower types with fixed upgrades and special abilities
    const towerTypes = [
        {   // Archer - Fast, long range, low damage, cheap
            name: "Archer",
            color: "#228b22",
            cost: 25,
            dmg: 10,
            rate: 300,
            range: 180,
            icon: towerIcons.archer,
            upgrades: {
                dmg: 5,
                rate: -50,
                range: 20,
                special: {
                    name: "MultiShot!",
                    cost: 5,
                    purchased: false,
                    description: "Attacks 3 units at the same time (2 bullets get fired at two different targets)"
                }
            },
            bulletType: "arrow"
        },
        {   // Cannon - Expensive, AOE damage
            name: "Cannon",
            cost: 100,
            color: "#696969",
            range: 150,
            dmg: 35,
            rate: 1200,
            icon: towerIcons.cannon,
            upgrades: {
                dmg: 15,
                rate: -150,
                range: 15,
                special: {
                    name: "Explode!",
                    cost: 5,
                    purchased: false,
                    description: "Fires exploding bombs that deal damage to every unit in the explosion radius"
                }
            },
            bulletType: "cannonball",
            aoeRadius: 40
        },
        {   // Mage - Slow, high damage with zap upgrade
            name: "Mage",
            cost: 120,
            color: "#5a006c",
            range: 130,
            dmg: 80,
            rate: 2000,
            icon: towerIcons.mage,
            upgrades: {
                dmg: 20,
                rate: -100,
                range: 15,
                special: {
                    name: "Zap!",
                    cost: 5,
                    purchased: false,
                    description: "Bullets also deal an electric bolt that strikes the hit enemy and 4 additional enemies behind it"
                }
            },
            bulletType: "magic"
        },
        {   // Fire - Short range, constant damage
            name: "Fire Tower",
            cost: 80,
            color: "#FF4500",
            range: 60,
            dmg: 20,
            rate: 100,
            icon: towerIcons.fire,
            upgrades: {
                dmg: 5,
                rate: -20,
                size: 5,
                special: {
                    name: "AOE!",
                    cost: 5,
                    purchased: false,
                    description: "Flame deals AOE damage to all enemies in its path"
                }
            },
            bulletType: "flame",
            flameWidth: 10
        },
        {   // Ice Tower - Slows enemies
            name: "Ice Tower",
            cost: 90,
            color: "#007acc",
            range: 140,
            dmg: 15,
            rate: 800,
            icon: towerIcons.ice,
            upgrades: {
                slow: 0.5,
                rate: -100,
                range: 15,
                special: {
                    name: "Freeze!",
                    cost: 5,
                    duration: 5000,
                    purchased: false,
                    description: "Freezes all enemies in range for 5 seconds every 30 seconds"
                }
            },
            bulletType: "ice",
            slowAmount: 0.5
        },
        {   // Sniper Tower - Very long range, slow rate, high damage
            name: "Sniper",
            color: "#333333",
            cost: 150,
            range: 9999,
            dmg: 100,
            rate: 2500,
            icon: towerIcons.sniper,
            upgrades: {
                dmg: 30,
                rate: -200,
                range: 25,
                special: {
                    name: "Pierce!",
                    cost: 5,
                    purchased: false,
                    description: "Bullets jump to one additional enemy after hitting the first target"
                }
            },
            bulletType: "sniper"
        }
    ];

    // Game objects
    let towers = [], enemies = [], bullets = [], lastSpawn = 0, waveInterval = 900;
    let lastUpdateTime = Date.now();

    // Initialization
    const GAME_WIDTH = 1200;
    const GAME_HEIGHT = 800;
    let gameScale = 1;

    function resizeCanvas() {
        // Calculate scale to fit the game in the window
        const scaleX = window.innerWidth / GAME_WIDTH;
        const scaleY = window.innerHeight / GAME_HEIGHT;
        gameScale = Math.min(scaleX, scaleY);

        // Set canvas size
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // Scale the canvas to fit the window while maintaining aspect ratio
        canvas.style.width = `${GAME_WIDTH * gameScale}px`;
        canvas.style.height = `${GAME_HEIGHT * gameScale}px`;

        // Recalculate path based on fixed game dimensions
        setupPath();
        generateMapElements();
    }

    function preloadTowerIcons() {
        return Promise.all(towerTypes.map(tower => {
            return new Promise((resolve) => {
                // Only create new image if not already created
                if (!tower.iconImage) {
                    const img = new Image();
                    img.onload = () => resolve();
                    img.src = 'data:image/svg+xml,' + encodeURIComponent(tower.icon);
                    tower.iconImage = img;
                } else {
                    resolve();  // Already loaded
                }
            });
        }));
    }

    function setupPath() {
        // Clear previous path
        path = [];
        
        // Define the path based on the selected map
        switch(gameConfig.map) {
            case 1: setupMap1(); break;
            case 2: setupMap2(); break;
            case 3: setupMap3(); break;
            case 4: setupMap4(); break;
            case 5: setupMap5(); break;
            case 6: setupMap6(); break;
        }
        
        // Generate map elements based on the new path
        generateMapElements();
    }

    function setupTowerBar() {
        towerBar.innerHTML = '';
        towerTypes.forEach((tower, index) => {
            const icon = document.createElement('div');
            icon.className = 'tower-icon';
            icon.innerHTML = tower.icon;
            icon.title = `${tower.name} (${tower.cost} gold)`;
            icon.dataset.index = index;
            icon.addEventListener('mousedown', startDragTower);
            icon.addEventListener('touchstart', startDragTower, { passive: false });
            towerBar.appendChild(icon);
        });
    }

    function startDragTower(e) {
        e.preventDefault();
        const index = parseInt(e.currentTarget.dataset.index);
        const towerType = towerTypes[index];

        if (gameState.gold < towerType.cost) {
            alert("Not enough gold!");
            return;
        }

        draggingTower = {
            type: {...towerType},
            x: 0,
            y: 0,
            width: 48,
            height: 48,
            range: towerType.range
        };

        // Calculate initial position
        const rect = canvas.getBoundingClientRect();
        if (e.type === 'mousedown') {
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
        } else if (e.type === 'touchstart') {
            dragOffsetX = e.touches[0].clientX - rect.left;
            dragOffsetY = e.touches[0].clientY - rect.top;
        }

        // Convert to game coordinates
        draggingTower.x = (dragOffsetX) * (canvas.width / rect.width);
        draggingTower.y = (dragOffsetY) * (canvas.height / rect.height);

        // Add event listeners for dragging
        document.addEventListener('mousemove', dragTower);
        document.addEventListener('touchmove', dragTower, { passive: false });
        document.addEventListener('mouseup', dropTower);
        document.addEventListener('touchend', dropTower);
    }

    function dragTower(e) {
        if (!draggingTower) return;
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.type === 'mousemove') {
            clientX = e.clientX;
            clientY = e.clientY;
        } else if (e.type === 'touchmove') {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        }

        // Convert to game coordinates
        draggingTower.x = (clientX - rect.left) * (canvas.width / rect.width);
        draggingTower.y = (clientY - rect.top) * (canvas.height / rect.height);
    }

    function dropTower(e) {
        if (!draggingTower) return;
        e.preventDefault();

        // Remove event listeners
        document.removeEventListener('mousemove', dragTower);
        document.removeEventListener('touchmove', dragTower);
        document.removeEventListener('mouseup', dropTower);
        document.removeEventListener('touchend', dropTower);

        // Check if position is valid (not on path or near tower bar)
        const validPosition = isValidTowerPosition(draggingTower.x, draggingTower.y);

        if (validPosition) {
            // Place the tower
            gameState.gold -= draggingTower.type.cost;
            towers.push({
                x: draggingTower.x,
                y: draggingTower.y,
                type: {...draggingTower.type},
                lastShot: 0,
                level: 1,
                upgrades: {
                    dmg: 0,
                    rate: 0,
                    range: 0,
                    slow: 0,
                    special: draggingTower.type.upgrades.special ? 
                        {...draggingTower.type.upgrades.special, purchased: false} : null
                },
                flameWidth: draggingTower.type.bulletType === "flame" ? 10 : 0,
                lastFreeze: 0,
                placedBy: gameConfig.isMultiplayer ? gameConfig.playerRole : 'single'
            });
            
            towers.push(newTower);

            // Send multiplayer message if in multiplayer mode
            if (gameConfig.isMultiplayer) {
                multiplayerManager.sendMessage('towerPlaced', {
                    x: newTower.x,
                    y: newTower.y,
                    type: newTower.type,
                    playerId: gameConfig.playerRole
                });
            }

            updateUI();
        }
        draggingTower = null;
    }

    function isValidTowerPosition(x, y) {
        // Check if position is too close to path
        for (let i = 0; i < path.length - 1; i++) {
            const dist = pointLineDist(x, y, path[i].x, path[i].y, path[i+1].x, path[i+1].y);
            if (dist < 42) {
                return false;
            }
        }

        // Check if position is too close to start/end
        if (Math.hypot(x - path[0].x, y - path[0].y) < 60) return false;
        if (Math.hypot(x - path[path.length-1].x, y - path[path.length-1].y) < 60) return false;

        // Check if position is too close to other towers
        for (const tower of towers) {
            if (Math.hypot(x - tower.x, y - tower.y) < 48) {
                return false;
            }
        }

        // Check if position is too close to tower bar area (bottom center)
        const towerBarArea = {
            x: canvas.width / 2,
            y: canvas.height - 60,
            width: 300,
            height: 80
        };

        if (x > towerBarArea.x - towerBarArea.width/2 &&
            x < towerBarArea.x + towerBarArea.width/2 &&
            y > towerBarArea.y - towerBarArea.height/2 &&
            y < towerBarArea.y + towerBarArea.height/2) {
            return false;
        }

        return true;
    }

    function pointLineDist(px, py, ax, ay, bx, by) {
        let dx = bx - ax, dy = by - ay;
        let len = dx * dx + dy * dy;
        let t = len === 0 ? 0 : ((px - ax) * dx + (py - ay) * dy) / len;
        t = Math.max(0, Math.min(1, t));
        let lx = ax + t * dx, ly = ay + t * dy;
        return Math.hypot(px - lx, py - ly);
    }

    function generateMapElements() {
        mapElements = [];
        let count = Math.floor(canvas.width * canvas.height / 42000);

        for (let i = 0; i < count; i++) placeElement('tree1', 34, 0.54);
        for (let i = 0; i < count/2; i++) placeElement('tree2', 27, 0.6);
        for (let i = 0; i < count/2; i++) placeElement('tree3', 30, 0.6);
        for (let i = 0; i < count/3; i++) placeElement('rock', 25, 0.8);

        function placeElement(type, rad, alpha) {
            let ok = false, tries = 0, x, y;
            while (!ok && tries < 120) {
                x = rad + Math.random() * (canvas.width - 2 * rad);
                y = rad + Math.random() * (canvas.height - 2 * rad);
                ok = true;

                // Check path distance
                for (let i = 0; i < path.length - 1; i++) {
                    let d = pointLineDist(x, y, path[i].x, path[i].y, path[i+1].x, path[i+1].y);
                    if (d < 42) { ok = false; break; }
                }

                // Check start/end distance
                if (Math.hypot(x - path[0].x, y - path[0].y) < 60) ok = false;
                if (Math.hypot(x - path[path.length-1].x, y - path[path.length-1].y) < 60) ok = false;

                // Check other elements
                for (let el of mapElements) {
                    if (Math.hypot(x - el.x, y - el.y) < el.r + rad + 4) {
                        ok = false;
                        break;
                    }
                }

                tries++;
            }

            if (ok) {
                mapElements.push({
                    type: type,
                    x: x, y: y, r: rad, a: alpha,
                    shape: type.includes('rock') ? Math.floor(Math.random() * 3) : 0
                });
            }
        }
    }

    // Start the wave
    function startWave() {
        gameState.waveActive = true;
        gameState.enemiesInWave = gameState.nextWaveEnemies;
        gameState.enemiesLeft = gameState.enemiesInWave;
        gameState.enemiesKilled = 0;
        gameState.enemiesTotal = gameState.enemiesInWave;

        // Calculate enemies for next wave
        gameState.nextWaveEnemies = 8 + gameState.wave * 3;
        if (gameState.wave < MAX_WAVE) {
            waveNumEl.textContent = `${gameState.wave}/${MAX_WAVE}`;
            enemiesKilledEl.textContent = `${gameState.nextWaveEnemies} next`;
        } else {
            waveNumEl.textContent = `${gameState.wave}/${MAX_WAVE}`;
            enemiesKilledEl.textContent = `${gameState.enemiesKilled}/${gameState.enemiesTotal}`;
        }

        startButton.disabled = true;
        lastSpawn = Date.now() - waveInterval;

        // Send multiplayer message if in multiplayer mode
        if (gameConfig.isMultiplayer && gameConfig.playerRole === 'host') {
            multiplayerManager.sendMessage('waveStarted', {
                wave: gameState.wave,
                enemies: gameState.enemiesInWave
            });
        }
    }

    // Spawn an enemy based on the current wave
    function spawnEnemy() {
        // Determine enemy tier based on wave number
        let tierIndex = Math.min(
            Math.floor((gameState.wave - 1) / 2), // Slowly increase tiers every 2 waves
            4 // Never go beyond T5
        );

        // Ensure we never spawn higher tiers than intended for the wave
        if (gameState.wave < 3) tierIndex = 0; // Only T1 in waves 1-2
        else if (gameState.wave < 5) tierIndex = 1; // Up to T2 in waves 3-4
        else if (gameState.wave < 7) tierIndex = 2; // Up to T3 in waves 5-6
        else if (gameState.wave < 9) tierIndex = 3; // Up to T4 in waves 7-8

        // Small chance to spawn one tier higher (but not beyond T5)
        if (Math.random() < 0.15 && gameState.wave > 1) {
            tierIndex = Math.min(tierIndex + 1, 4);
        }

        const enemyType = enemyTiers[tierIndex];
        const hpMultiplier = gameConfig.difficulties[gameConfig.difficulty].enemyHpMultiplier;

        enemies.push({
            x: path[0].x,
            y: path[0].y,
            pathIndex: 0,
            hp: enemyType.hp * hpMultiplier * (1 + (gameState.wave-1)*0.1),
            maxHp: enemyType.hp * hpMultiplier * (1 + (gameState.wave-1)*0.1),
            speed: enemyType.speed,
            alive: true,
            type: enemyType,
            goldValue: enemyType.goldValue,
            lastBlink: 0,
            blinkColor: "#ffffff",
            currentTier: enemyType.tier,
            originalTier: enemyType.tier,
            slowTimer: 0,
            slowAmount: 1, // 1 = normal speed
            freezeTimer: 0
        });
    }

    // Freeze enemies in range (for Ice Tower special ability)
    function freezeEnemies(tower) {
        const range = tower.type.range + (tower.upgrades.range || 0);
        enemies.forEach(e => {
            if (e.alive && Math.hypot(e.x - tower.x, e.y - tower.y) < range) {
                e.freezeTimer = tower.type.upgrades.special.duration; // 5 seconds
            }
        });
    }

    function update() {
        const now = Date.now();
        const deltaTime = now - lastUpdateTime;
        lastUpdateTime = now;

        // Spawn enemies
        if (gameState.waveActive && gameState.enemiesInWave > 0 && Date.now() - lastSpawn > waveInterval) {
            spawnEnemy();
            lastSpawn = Date.now();
            gameState.enemiesInWave--;
        }

        // Move enemies
        for (const e of enemies) {
            // Handle slow effects
            if (e.slowTimer > 0) {
                e.slowTimer -= deltaTime;
                if (e.slowTimer <= 0) {
                    e.slowAmount = 1; // Reset to normal speed
                }
            }

            // Handle freeze effect
            if (e.freezeTimer > 0) {
                e.freezeTimer -= deltaTime;
                continue; // Skip movement if frozen
            }

            let tgt = path[e.pathIndex + 1];
            if (!tgt) continue;

            let dx = tgt.x - e.x, dy = tgt.y - e.y, dist = Math.hypot(dx, dy);
            let moveSpeed = e.speed * e.slowAmount;

            if (dist < moveSpeed) {
                e.x = tgt.x;
                e.y = tgt.y;
                e.pathIndex++;

                if (e.pathIndex >= path.length - 1) {
                    e.alive = false;
                    gameState.lives = Math.max(0, gameState.lives - e.type.tier);
                    gameState.enemiesKilled++;
                    
                    // Send multiplayer update for shared lives
                    if (gameConfig.isMultiplayer) {
                        multiplayerManager.sendMessage('gameState', {
                            lives: gameState.lives,
                            wave: gameState.wave
                        });
                    }
                    
                    updateUI();
                }
            } else {
                e.x += moveSpeed * dx / dist;
                e.y += moveSpeed * dy / dist;
            }
        }

        // Towers shoot
        for (const t of towers) {
            // Handle special ability cooldowns
            if (t.type.name === "Ice Tower" && t.upgrades.special?.purchased) {
                if (!t.lastFreeze) t.lastFreeze = 0;
                if (now - t.lastFreeze >= 30000) { // 30 seconds
                    freezeEnemies(t);
                    t.lastFreeze = now;
                }
            }

            if (Date.now() - t.lastShot >= (t.type.rate + (t.upgrades.rate || 0))) {
                let target = null;
                let highestPathIndex = -1;

                // Find all enemies in range
                const enemiesInRange = enemies.filter(e => 
                    e.alive && Math.hypot(e.x - t.x, e.y - t.y) < (t.type.range + (t.upgrades.range || 0)));

                // Special targeting for ice tower
                if (t.type.name === "Ice Tower") {
                    // Find un-slowed enemies first
                    const unSlowedEnemies = enemiesInRange.filter(e => e.slowAmount >= 1);
                    
                    // Find furthest un-slowed enemy
                    for (const e of unSlowedEnemies) {
                        if (e.pathIndex > highestPathIndex) {
                            highestPathIndex = e.pathIndex;
                            target = e;
                        }
                    }
                    
                    // If no un-slowed enemies, find furthest enemy in range
                    if (!target) {
                        for (const e of enemiesInRange) {
                            if (e.pathIndex > highestPathIndex) {
                                highestPathIndex = e.pathIndex;
                                target = e;
                            }
                        }
                    }
                }
                // Standard targeting for other towers
                else {
                    // Find enemy furthest along path
                    for (const e of enemiesInRange) {
                        if (e.pathIndex > highestPathIndex) {
                            highestPathIndex = e.pathIndex;
                            target = e;
                        }
                    }
                }

                if (target) {
                    // Handle special abilities
                    if (t.type.name === "Archer" && t.upgrades.special?.purchased) {
                        // MultiShot - find 2 additional targets
                        const additionalTargets = enemiesInRange
                            .filter(e => e !== target)
                            .sort((a, b) => b.pathIndex - a.pathIndex) // Sort by furthest along path
                            .slice(0, 2); // Take top 2
                        
                        // Shoot at main target and additional targets
                        [target, ...additionalTargets].forEach(tgt => {
                            if (tgt) {
                                bullets.push({
                                    x: t.x,
                                    y: t.y,
                                    tx: tgt.x,
                                    ty: tgt.y,
                                    dmg: t.type.dmg + (t.upgrades.dmg || 0),
                                    target: tgt,
                                    color: t.type.color,
                                    speed: 12,
                                    type: t.type.bulletType,
                                    tower: t
                                });
                            }
                        });
                    }
                    else if (t.type.name === "Sniper" && t.upgrades.special?.purchased) {
                        // Piercing shot - find secondary target
                        bullets.push({
                            x: t.x,
                            y: t.y,
                            tx: target.x,
                            ty: target.y,
                            dmg: t.type.dmg + (t.upgrades.dmg || 0),
                            target: target,
                            color: t.type.color,
                            speed: 20,
                            type: t.type.bulletType,
                            tower: t,
                            pierce: true // Mark as piercing bullet
                        });
                    }
                    else {
                        // Standard projectile for all towers except fire tower
                        if (t.type.bulletType !== "flame") {
                            bullets.push({
                                x: t.x,
                                y: t.y,
                                tx: target.x,
                                ty: target.y,
                                dmg: t.type.dmg + (t.upgrades.dmg || 0),
                                target: target,
                                color: t.type.color,
                                speed: t.type.bulletType === "arrow" ? 12 :
                                    t.type.bulletType === "sniper" ? 20 : 6,
                                aoeRadius: t.type.aoeRadius || 0,
                                type: t.type.bulletType,
                                tower: t,
                                slowAmount: t.type.slowAmount || 0
                            });
                        }
                    }

                    // Special effects based on tower type
                    if (t.type.name === "Mage" && t.upgrades.special?.purchased) {
                        // Chain lightning effect
                        let chainTargets = [target];
                        let currentTarget = target;

                        for (let i = 0; i < 4; i++) { // 4 additional targets
                            let nextTarget = enemies.find(e =>
                                e.alive &&
                                e !== currentTarget &&
                                !chainTargets.includes(e) &&
                                Math.hypot(e.x - currentTarget.x, e.y - currentTarget.y) < 100
                            );

                            if (nextTarget) {
                                chainTargets.push(nextTarget);
                                currentTarget = nextTarget;
                            } else {
                                break;
                            }
                        }

                        // Create zap effects between targets
                        chainTargets.forEach((tgt, index) => {
                            tgt.hp -= (t.type.dmg + (t.upgrades.dmg || 0)) * (1.0 - (index * 0.2));
                            tgt.lastBlink = Date.now();
                            tgt.blinkColor = "#ffff00";
                            
                            if (index > 0) {
                                bullets.push({
                                    x: chainTargets[index-1].x,
                                    y: chainTargets[index-1].y,
                                    tx: tgt.x,
                                    ty: tgt.y,
                                    dmg: (t.type.dmg + (t.upgrades.dmg || 0)) * (1.0 - (index * 0.2)),
                                    color: "#FFFF00",
                                    speed: 20,
                                    type: "zap",
                                    lifetime: 30
                                });
                            }
                        });
                    }
                    else if (t.type.name === "Fire Tower") {
                        // Fire tower deals damage directly to the target
                        target.hp -= (t.type.dmg + (t.upgrades.dmg || 0));
                        
                        // If AOE is purchased, damage all enemies in flame path
                        if (t.upgrades.special?.purchased) {
                            const angle = Math.atan2(target.y - t.y, target.x - t.x);
                            const distance = Math.hypot(target.x - t.x, target.y - t.y);
                            
                            enemies.forEach(e => {
                                if (e.alive && e !== target) {
                                    // Check if enemy is within flame width of the line
                                    const pointLineDist = Math.abs(
                                        (target.y - t.y) * e.x - (target.x - t.x) * e.y + target.x * t.y - target.y * t.x
                                    ) / distance;
                                    
                                    if (pointLineDist < t.type.flameWidth + (t.upgrades.size || 0)) {
                                        e.hp -= (t.type.dmg + (t.upgrades.dmg || 0)) * 0.5; // 50% damage for AOE
                                    }
                                }
                            });
                        }
                    }

                    t.lastShot = Date.now();
                }
            }
        }

        // Projectile movement and collision
        for (const b of bullets) {
            if (b.type === "zap") {
                if (b.lifetime <= 0) {
                    // Apply damage when zap expires
                    if (b.target && b.target.alive) {
                        b.target.hp -= b.dmg;
                    }
                    b.hit = true;
                } else {
                    b.lifetime--;
                }
            }
            else if (b.type === "flame") {
                // Flame just moves toward target
                if (!b.target?.alive) {
                    b.hit = true;
                    continue;
                }

                let dx = b.tx - b.x, dy = b.ty - b.y, dist = Math.hypot(dx, dy);
                if (dist < b.speed) {
                    b.hit = true;
                } else {
                    b.x += b.speed * dx / dist;
                    b.y += b.speed * dy / dist;
                }
            } else {
                let dx = b.tx - b.x, dy = b.ty - b.y, dist = Math.hypot(dx, dy);
                if (dist < b.speed || !b.target?.alive) {
                    // Handle AOE damage (for Cannon's Explode!)
                    if (b.aoeRadius > 0 && b.tower?.upgrades.special?.purchased) {
                        const aoeTargets = enemies.filter(e =>
                            e.alive && Math.hypot(e.x - b.x, e.y - b.y) < b.aoeRadius);
                        aoeTargets.forEach(e => {
                            e.hp -= b.dmg * 0.7; // AOE does 70% damage
                            e.lastBlink = Date.now(); // Visual feedback
                            e.blinkColor = "#ff0000";
                        });

                        // Create explosion effect
                        bullets.push({
                            x: b.x,
                            y: b.y,
                            radius: b.aoeRadius,
                            type: "explosion",
                            lifetime: 30
                        });
                    }

                    // Handle direct damage
                    if (b.target && b.target.alive) {
                        b.target.hp -= b.dmg;

                        // Apply slow effect for ice tower
                        if (b.slowAmount > 0) {
                            b.target.slowAmount = b.slowAmount;
                            b.target.slowTimer = 2000; // 2 seconds slow
                        }

                        // Handle piercing for sniper tower
                        if (b.pierce) {
                            // Find another target in range
                            const nextTarget = enemies.find(e => 
                                e.alive && 
                                e !== b.target &&
                                Math.hypot(e.x - b.x, e.y - b.y) < (b.tower.type.range + (b.tower.upgrades.range || 0)));
                            
                            if (nextTarget) {
                                bullets.push({
                                    x: b.x,
                                    y: b.y,
                                    tx: nextTarget.x,
                                    ty: nextTarget.y,
                                    dmg: b.dmg, // Full damage to second target
                                    target: nextTarget,
                                    color: b.tower.type.color,
                                    speed: 20,
                                    type: "sniper",
                                    tower: b.tower
                                });
                            }
                        }
                    }

                    b.hit = true;
                } else {
                    b.x += b.speed * dx / dist;
                    b.y += b.speed * dy / dist;
                }
            }
        }

        // Cleanup
        bullets = bullets.filter(b => !b.hit && (!b.lifetime || b.lifetime > 0));

        // Reward for killing enemies and handle tier downgrades
        let killed = enemies.filter(e => e.hp <= 0 && e.alive);
        if (killed.length > 0) {
            let totalGold = 0;
            let totalCrystals = 0;

            for (const e of killed) {
                if (e.currentTier > 1) {
                    // Downgrade the enemy to the next lower tier
                    const newTierIndex = e.currentTier - 2;
                    const newTier = enemyTiers[newTierIndex];

                    if (newTier && newTier.tier < e.currentTier) {
                        e.type = newTier;
                        e.currentTier = newTier.tier;
                        e.hp = newTier.hp * gameConfig.difficulties[gameConfig.difficulty].enemyHpMultiplier * (1 + (gameState.wave-1)*0.1);
                        e.maxHp = e.hp;
                        e.goldValue = newTier.goldValue;

                        // Make the enemy blink when downgraded
                        e.lastBlink = Date.now();
                        e.blinkColor = "#ffffff";
                    } else {
                        e.alive = false;
                        totalGold += e.goldValue;
                        gameState.enemiesLeft--;
                        gameState.enemiesKilled++;
                    }
                } else {
                    e.alive = false;
                    totalGold += e.goldValue;
                    totalCrystals += Math.random() < 0.22 ? 1 : 0;
                    gameState.enemiesLeft--;
                    gameState.enemiesKilled++;
                }
            }

            gameState.gold += totalGold;
            gameState.crystals += totalCrystals;
            updateUI();
        }

        // Clean up dead enemies (only T1 enemies can actually die)
        enemies = enemies.filter(e => e.alive);

        // Check if wave is complete
        if (gameState.enemiesInWave == 0 && enemies.length == 0 && gameState.waveActive) {
            if (gameState.wave < MAX_WAVE) {
                gameState.wave++;
                waveNumEl.textContent = `${gameState.wave}/${MAX_WAVE}`;
                enemiesKilledEl.textContent = `${gameState.nextWaveEnemies} next`;
            } else {
                waveNumEl.textContent = `${gameState.wave}/${MAX_WAVE}`;
                enemiesKilledEl.textContent = `${gameState.enemiesKilled}/${gameState.enemiesTotal}`;
            }
            gameState.waveActive = false;
            startButton.disabled = false;
        }

        // Game over
        if (gameState.lives <= 0) {
            alert("Game Over!");
            if (gameConfig.isMultiplayer) {
                multiplayerManager.backToMain();
            } else {
                window.location.reload();
            }
        }
    }

    // UI functions
    function updateUI() {
		// Update connection status
		const statusEl = document.getElementById('connectionStatus');
		if (this.isConnected) {
			statusEl.textContent = `Connected - ${this.isHost ? 'Hosting' : 'Guest'} - Code: ${this.lobbyCode}`;
			statusEl.style.color = '#27ae60';
		} else {
			statusEl.textContent = 'Disconnected';
			statusEl.style.color = '#e74c3c';
		}

		// Update player list
		multiplayerManager.updatePlayerList();

		// Show/hide host controls
		const hostControls = document.getElementById('hostControls');
		if (this.isHost && this.isConnected) {
			hostControls.style.display = 'block';
		} else {
			hostControls.style.display = 'none';
		}
	}

    // Upgrade menu
    function showUpgradeMenu(tower, clickX, clickY) {
        const upgradeCost = 30 + gameState.wave * 5;

        // Create stats display section
        let statsHTML = `
        <div class="tower-stats">
            <h3>${tower.type.name} (Level ${tower.level || 1})</h3>
            <div class="stat-row">
                <span class="stat-name">Damage:</span>
                <span class="stat-value">${tower.type.dmg + (tower.upgrades.dmg || 0)}</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Range:</span>
                <span class="stat-value">${tower.type.range + (tower.upgrades.range || 0)}</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Attack Speed:</span>
                <span class="stat-value">${(1000/(tower.type.rate + (tower.upgrades.rate || 0))).toFixed(1)}/s</span>
            </div>`;

        // Add special stats if applicable
        if ('slowAmount' in tower.type) {
            statsHTML += `
            <div class="stat-row">
                <span class="stat-name">Slow:</span>
                <span class="stat-value">${(tower.type.slowAmount * 100).toFixed(0)}%</span>
            </div>`;
        }
        
        if (tower.upgrades.special?.purchased) {
            statsHTML += `
            <div class="stat-row">
                <span class="stat-name">Special:</span>
                <span class="stat-value">${tower.type.upgrades.special.name} (Active)</span>
            </div>`;
        }

        // Show who placed the tower in multiplayer
        if (gameConfig.isMultiplayer && tower.placedBy) {
            const playerName = tower.placedBy === 'host' ? 'Host' : 'Guest';
            statsHTML += `
            <div class="stat-row">
                <span class="stat-name">Placed by:</span>
                <span class="stat-value">${playerName}</span>
            </div>`;
        }

        statsHTML += `</div><div class="upgrade-options">`;

        let upgradeOptions = '';
        // Damage Upgrade Button (if exists)
        if ('dmg' in tower.type.upgrades) {
            upgradeOptions += `
            <button class="upgrade-option" data-upgrade="dmg" ${gameState.gold < upgradeCost ? "disabled" : ""}>
                <span>💥</span>
                <span class="upgrade-name">Attack Damage +${tower.type.upgrades.dmg}</span>
                <span class="upgrade-cost">${upgradeCost} Gold</span>
            </button>`;
        }

        // Attack Speed Upgrade Button (if exists)
        if ('rate' in tower.type.upgrades) {
            upgradeOptions += `
            <button class="upgrade-option" data-upgrade="rate" ${gameState.gold < upgradeCost ? "disabled" : ""}>
                <span>⏱️</span>
                <span class="upgrade-name">Attack Speed (${-tower.type.upgrades.rate/1000}s)</span>
                <span class="upgrade-cost">${upgradeCost} Gold</span>
            </button>`;
        }

        // Attack Range Upgrade Button (if exists)
        if ('range' in tower.type.upgrades) {
            upgradeOptions += `
            <button class="upgrade-option" data-upgrade="range" ${gameState.gold < upgradeCost ? "disabled" : ""}>
                <span>📏</span>
                <span class="upgrade-name">Attack Range +${tower.type.upgrades.range}</span>
                <span class="upgrade-cost">${upgradeCost} Gold</span>
            </button>`;
        }

        // Size Upgrade Button (for Fire Tower)
        if ('size' in tower.type.upgrades) {
            upgradeOptions += `
            <button class="upgrade-option" data-upgrade="size" ${gameState.gold < upgradeCost ? "disabled" : ""}>
                <span>🔥</span>
                <span class="upgrade-name">Flame Size +${tower.type.upgrades.size}</span>
                <span class="upgrade-cost">${upgradeCost} Gold</span>
            </button>`;
        }

        // Slow Upgrade Button (if exists)
        if ('slow' in tower.type.upgrades) {
            upgradeOptions += `
            <button class="upgrade-option" data-upgrade="slow" ${gameState.gold < upgradeCost ? "disabled" : ""}>
                <span>❄️</span>
                <span class="upgrade-name">Slow +${(tower.type.upgrades.slow*100).toFixed(0)}%</span>
                <span class="upgrade-cost">${upgradeCost} Gold</span>
            </button>`;
        }

        // Special Ability Button (if exists)
        if (tower.type.upgrades.special) {
            upgradeOptions += `
            <button class="upgrade-option" data-upgrade="special"
                ${(gameState.crystals < tower.type.upgrades.special.cost || tower.upgrades.special?.purchased) ? "disabled" : ""}>
                <span>✨</span>
                <span class="upgrade-name">${tower.type.upgrades.special.name}</span>
                <span class="upgrade-description">${tower.type.upgrades.special.description}</span>
                <span class="upgrade-cost">${tower.type.upgrades.special.cost} Crystals</span>
            </button>`;
        }

        // Combine stats and upgrade options
        upgradeMenu.innerHTML = statsHTML + upgradeOptions + '</div>';
        upgradeMenu.style.display = 'grid';
        upgradeMenu.style.left = '20px';
        upgradeMenu.style.bottom = '80px';

        const buttons = upgradeMenu.querySelectorAll('.upgrade-option');
        buttons.forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();

                const upgradeType = this.getAttribute('data-upgrade');

                if (upgradeType === 'special') {
                    if (gameState.crystals < tower.type.upgrades.special.cost) {
                        alert("Not enough crystals!");
                        return;
                    }
                    gameState.crystals -= tower.type.upgrades.special.cost;
                    tower.upgrades.special.purchased = true;
                    tower.level = (tower.level || 1) + 1;
                } else {
                    if (gameState.gold < upgradeCost) {
                        alert("Not enough gold!");
                        return;
                    }

                    gameState.gold -= upgradeCost;
                    tower.level = (tower.level || 1) + 1;

                    switch(upgradeType) {
                        case 'dmg':
                            tower.upgrades.dmg = (tower.upgrades.dmg || 0) + tower.type.upgrades.dmg;
                            break;
                        case 'rate':
                            tower.upgrades.rate = (tower.upgrades.rate || 0) + tower.type.upgrades.rate;
                            break;
                        case 'range':
                            tower.upgrades.range = (tower.upgrades.range || 0) + tower.type.upgrades.range;
                            break;
                        case 'size':
                            tower.type.flameWidth += tower.type.upgrades.size;
                            break;
                        case 'slow':
                            tower.type.slowAmount += tower.type.upgrades.slow;
                            break;
                    }
                }

                // Send multiplayer message if in multiplayer mode
                if (gameConfig.isMultiplayer) {
                    multiplayerManager.sendMessage('towerUpgraded', {
                        x: tower.x,
                        y: tower.y,
                        upgrades: tower.upgrades,
                        level: tower.level
                    });
                }

                updateUI();
                showUpgradeMenu(tower, clickX, clickY);
            });
        });

        const closeMenu = function(e) {
            if (!upgradeMenu.contains(e.target)) {
                upgradeMenu.style.display = 'none';
                document.removeEventListener('mousedown', closeMenu);
            }
        };

        document.addEventListener('mousedown', closeMenu);
    }

    // Click handler
    function handleCanvasClick(evt) {
        evt.preventDefault();

        // Calculate coordinates
        const rect = canvas.getBoundingClientRect();
        const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
        const y = (evt.clientY - rect.top) * (canvas.height / rect.height);

        // Check if an enemy was clicked
        for (let e of enemies) {
            const dist = Math.hypot(x - e.x, y - e.y);
            if (dist <= 15) {  // Enemy click radius
                showEnemyInfo(e);
                return;
            }
        }

        // Check if a tower was clicked
        for (let t of towers) {
            const dist = Math.hypot(x - t.x, y - t.y);
            if (dist <= 25) {  // Larger click radius
                selectedTower = t;
                showUpgradeMenu(t, x, y);
                return;
            }
        }

        // If no tower clicked, hide menus
        upgradeMenu.style.display = 'none';
        selectedTower = null;
    }

    // Draw enemy info when clicked
    function showEnemyInfo(enemy) {
        const hpMultiplier = gameConfig.difficulties[gameConfig.difficulty].enemyHpMultiplier;
        const baseHp = enemy.type.hp;
        const currentHp = enemy.hp;
        const maxHp = enemy.maxHp;

        upgradeMenu.innerHTML = `
            <div class="tower-stats">
                <h3>${enemy.type.name}</h3>
                <div class="stat-row">
                    <span class="stat-name">Tier:</span>
                    <span class="stat-value">${enemy.type.tier}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-name">HP:</span>
                    <span class="stat-value">${Math.round(currentHp)}/${Math.round(maxHp)} (Base: ${baseHp})</span>
                </div>
                <div class="stat-row">
                    <span class="stat-name">Speed:</span>
                    <span class="stat-value">${enemy.type.speed.toFixed(2)} ${enemy.slowAmount < 1 ? `(Slowed: ${(enemy.type.speed * enemy.slowAmount).toFixed(2)})` : ''}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-name">Gold Reward:</span>
                    <span class="stat-value">${enemy.type.goldValue}</span>
                </div>
                ${enemy.currentTier !== enemy.originalTier ? `
                <div class="stat-row">
                    <span class="stat-name">Downgraded:</span>
                    <span class="stat-value">T${enemy.currentTier} (from T${enemy.originalTier})</span>
                </div>` : ''}
                ${enemy.freezeTimer > 0 ? `
                <div class="stat-row">
                    <span class="stat-name">Status:</span>
                    <span class="stat-value">Frozen (${(enemy.freezeTimer/1000).toFixed(1)}s remaining)</span>
                </div>` : ''}
            </div>
        `;

        upgradeMenu.style.display = 'grid';
        upgradeMenu.style.left = '20px';
        upgradeMenu.style.bottom = '80px';

        const closeMenu = function(e) {
            if (!upgradeMenu.contains(e.target)) {
                upgradeMenu.style.display = 'none';
                document.removeEventListener('mousedown', closeMenu);
            }
        };

        document.addEventListener('mousedown', closeMenu);
    }

    // Drawing functions
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw path (for all maps)
        ctx.save();
        ctx.strokeStyle = "#5a3310";
        ctx.lineWidth = 32;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
        }
        ctx.shadowColor = "#40240a";
        ctx.shadowBlur = 18;
        ctx.stroke();

        // Draw path outline
        ctx.strokeStyle = "#7B4A20";
        ctx.lineWidth = 24;
        ctx.shadowColor = "transparent";
        ctx.stroke();
        ctx.restore();

        // Decorative elements
        for (const el of mapElements) {
            ctx.save();
            ctx.globalAlpha = el.a;

            if (el.type.includes('rock')) {
                ctx.save();
                ctx.globalAlpha = el.a;
                ctx.beginPath();

                switch(el.shape) {
                    case 0: // Round rock
                        ctx.arc(el.x, el.y, el.r, 0, Math.PI * 2);
                        break;
                    case 1: // Angular rock
                        ctx.moveTo(el.x - el.r, el.y - el.r * 0.6);
                        ctx.lineTo(el.x + el.r * 0.7, el.y - el.r);
                        ctx.lineTo(el.x + el.r, el.y + el.r * 0.5);
                        ctx.lineTo(el.x - el.r * 0.5, el.y + el.r);
                        ctx.closePath();
                        break;
                    case 2: // Oval rock
                        ctx.ellipse(el.x, el.y, el.r, el.r * 0.7, 0.4, 0, Math.PI * 2);
                        break;
                }

                // Fill and stroke
                ctx.fillStyle = '#a0a0a0';
                ctx.fill();
                ctx.strokeStyle = '#707070';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
            else if (el.type.includes('tree')) {
                if (el.type === 'tree1') {
                    ctx.beginPath();
                    ctx.arc(el.x, el.y, el.r*0.6, 0, Math.PI*2);
                    ctx.fillStyle = "#287d3c";
                    ctx.shadowColor = "#1a3819";
                    ctx.shadowBlur = 13;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.rect(el.x-3, el.y+el.r*0.4, 6, 10);
                    ctx.fillStyle = "#86592d";
                    ctx.shadowBlur = 0;
                    ctx.fill();
                }
                else if (el.type === 'tree2') {
                    ctx.beginPath();
                    ctx.moveTo(el.x, el.y-el.r*0.4);
                    ctx.lineTo(el.x-el.r*0.47, el.y+el.r*0.27);
                    ctx.lineTo(el.x+el.r*0.47, el.y+el.r*0.27);
                    ctx.closePath();
                    ctx.fillStyle = "#196a2e";
                    ctx.shadowColor = "#0c3c16";
                    ctx.shadowBlur = 11;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.rect(el.x-2.5, el.y+el.r*0.27, 5, 11);
                    ctx.fillStyle = "#68481d";
                    ctx.shadowBlur = 0;
                    ctx.fill();
                }
                else if (el.type === 'tree3') {
                    ctx.beginPath();
                    ctx.ellipse(el.x, el.y, el.r*0.5, el.r*0.36, 0.4, 0, Math.PI*2);
                    ctx.fillStyle = "#50b93e";
                    ctx.shadowColor = "#1a3819";
                    ctx.shadowBlur = 8;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.rect(el.x-2.5, el.y+el.r*0.2, 5, 8);
                    ctx.fillStyle = "#ad8323";
                    ctx.shadowBlur = 0;
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // Draw towers
        for (const t of towers) {
            if (!t) continue; // Skip if tower is null

            ctx.save();

            // Tower base
            ctx.beginPath();
            ctx.roundRect(t.x - 24, t.y - 24, 48, 48, 12);
            ctx.fillStyle = t.type.color;
            ctx.fill();

            // Black outline
            ctx.beginPath();
            ctx.roundRect(t.x - 24, t.y - 24, 48, 48, 12);
            ctx.strokeStyle = "#222";
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw player indicator for multiplayer
            if (gameConfig.isMultiplayer && t.placedBy) {
                ctx.beginPath();
                ctx.arc(t.x + 20, t.y - 20, 10, 0, Math.PI * 2);
                ctx.fillStyle = t.placedBy === 'host' ? '#3498db' : '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(t.placedBy === 'host' ? '1' : '2', t.x + 20, t.y - 20);
            }

            if (t.type.iconImage) {
                ctx.drawImage(t.type.iconImage, t.x - 25, t.y - 25, 50, 50);
            } else {
                // Fallback: simple "T" shape
                ctx.fillStyle = "#fff";
                ctx.fillRect(t.x - 8, t.y - 12, 16, 24); // Vertical
                ctx.fillRect(t.x - 12, t.y + 4, 24, 8);   // Horizontal
            }

            ctx.restore();

            // Fire tower effects
            if (t.type.name === "Fire Tower" && Date.now() - t.lastShot < 100) {
                const tgt = enemies.find(e => e.alive && Math.hypot(e.x-t.x, e.y-t.y) < t.type.range);
                if (tgt) {
                    const angle = Math.atan2(tgt.y - t.y, tgt.x - t.x);
                    const distance = Math.hypot(tgt.x - t.x, tgt.y - t.y);
                    const flameLength = Math.min(t.type.range, distance);

                    ctx.save();
                    ctx.translate(t.x, t.y);
                    ctx.rotate(angle);

                    // Flame gradient
                    const flameGradient = ctx.createLinearGradient(0, 0, flameLength, 0);
                    flameGradient.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
                    flameGradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.7)');
                    flameGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');

                    ctx.beginPath();
                    ctx.moveTo(24, 0);
                    ctx.lineTo(flameLength, -t.type.flameWidth);
                    ctx.lineTo(flameLength, t.type.flameWidth);
                    ctx.closePath();
                    ctx.fillStyle = flameGradient;
                    ctx.fill();

                    // Inner flame
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(flameLength, -t.type.flameWidth * 0.6);
                    ctx.lineTo(flameLength, t.type.flameWidth * 0.6);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
                    ctx.fill();

                    ctx.restore();
                }
            }
        }

        // Attack radius of selected tower
        if (selectedTower) {
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(selectedTower.x, selectedTower.y, selectedTower.type.range + (selectedTower.upgrades.range || 0), 0, Math.PI * 2);
            ctx.stroke();
        }

        // Draw dragging tower
        if (draggingTower) {
            ctx.save();
            ctx.globalAlpha = 0.8;

            // Check if position is valid
            const valid = isValidTowerPosition(draggingTower.x, draggingTower.y);
            ctx.strokeStyle = valid ? "#0f0" : "#f00";
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);

            // Draw tower base
            ctx.beginPath();
            ctx.roundRect(
                draggingTower.x - draggingTower.width/2,
                draggingTower.y - draggingTower.height/2,
                draggingTower.width,
                draggingTower.height,
                12
            );
            ctx.fillStyle = draggingTower.type.color;
            ctx.fill();
            ctx.stroke();

            // Draw the tower icon
            if (draggingTower.type.iconImage) {
                ctx.drawImage(draggingTower.type.iconImage, draggingTower.x - 25, draggingTower.y - 25, 50, 50);
            } else {
                // Fallback: draw SVG icon
                ctx.fillStyle = "#fff";
                ctx.fillRect(draggingTower.x - 8, draggingTower.y - 12, 16, 24);
                ctx.fillRect(draggingTower.x - 12, draggingTower.y + 4, 24, 8);
            }

            // Draw attack radius
            ctx.strokeStyle = valid ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
            ctx.fillStyle = valid ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(draggingTower.x, draggingTower.y, draggingTower.range, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Optional pulsating effect
            const pulseSize = Math.sin(Date.now() / 200) * 5 + 5;
            ctx.strokeStyle = valid ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 0, 0, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(draggingTower.x, draggingTower.y, draggingTower.range + pulseSize, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        // Draw all enemies with optimized code
        for (const e of enemies) {
            const isBlinking = e.lastBlink && Date.now() - e.lastBlink < 100;
            const isSelected = upgradeMenu.style.display !== 'none' && 
                            upgradeMenu.textContent.includes(e.type.name);
            const isFrozen = e.freezeTimer > 0;

            // Draw enemy body
            if (isSelected) {
                // Highlight selected enemy with yellow glow
                ctx.fillStyle = "#ffff00";
                ctx.beginPath();
                ctx.arc(e.x, e.y, 18, 0, 2*Math.PI);
                ctx.fill();
                
                // Draw actual enemy color inside highlight
                ctx.fillStyle = isBlinking ? "#ffffff" : e.type.color;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 15, 0, 2*Math.PI);
                ctx.fill();
            } else {
                // Normal enemy drawing
                ctx.fillStyle = isBlinking ? "#ffffff" : e.type.color;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 15, 0, 2*Math.PI);
                ctx.fill();
            }

            // Draw health bar (always visible)
            ctx.fillStyle = "#222";
            ctx.fillRect(e.x-16, e.y-18, 32, 5);
            ctx.fillStyle = "#4CAF50";
            ctx.fillRect(e.x-16, e.y-18, 32*e.hp/e.maxHp, 5);

            // Draw tier indicator (always visible)
            ctx.fillStyle = isBlinking ? "#fff" : "#fff";
            ctx.beginPath();
            ctx.arc(e.x, e.y, 6, 0, 2*Math.PI);
            ctx.fill();

            ctx.fillStyle = "#000";
            ctx.font = "bold 10px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(e.currentTier, e.x, e.y);

            // Draw freeze effect if frozen
            if (isFrozen) {
                ctx.strokeStyle = "#a0e1ff";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 18, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Projectiles
        for (const b of bullets) {
            if (b.type === "arrow") {
                const angle = Math.atan2(b.ty - b.y, b.tx - b.x);
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-15, -5);
                ctx.lineTo(-15, 5);
                ctx.closePath();
                ctx.fillStyle = b.color;
                ctx.fill();
                ctx.restore();
            }
            else if (b.type === "flame") {
                const angle = Math.atan2(b.ty - b.y, b.tx - b.x);
                const distance = Math.hypot(b.tx - b.x, b.ty - b.y);

                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(angle);

                const flameGradient = ctx.createLinearGradient(0, 0, distance, 0);
                flameGradient.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
                flameGradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.7)');
                flameGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(distance, -b.tower.type.flameWidth);
                ctx.lineTo(distance, b.tower.type.flameWidth);
                ctx.closePath();
                ctx.fillStyle = flameGradient;
                ctx.fill();

                // Inner brighter flame
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(distance, -b.tower.type.flameWidth * 0.6);
                ctx.lineTo(distance, b.tower.type.flameWidth * 0.6);
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
                ctx.fill();

                ctx.restore();
            }
            else if (b.type === "cannonball") {
                ctx.beginPath();
                ctx.arc(b.x, b.y, 8, 0, Math.PI * 2);
                const cannonGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, 8);
                cannonGrad.addColorStop(0, '#666');
                cannonGrad.addColorStop(0.5, '#FF8C00');
                cannonGrad.addColorStop(1, '#FF4500');
                ctx.fillStyle = cannonGrad;
                ctx.fill();
                
                if (b.hit && b.tower?.upgrades.special?.purchased) {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.aoeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 165, 0, 0.3)`;
                    ctx.fill();
                }
            }
            else if (b.type === "ice") {
                ctx.beginPath();
                ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
                const iceGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, 6);
                iceGrad.addColorStop(0, '#a0e1ff');
                iceGrad.addColorStop(1, '#007acc');
                ctx.fillStyle = iceGrad;
                ctx.fill();
                
                // Snowflake effect
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(b.x - 4, b.y);
                ctx.lineTo(b.x + 4, b.y);
                ctx.moveTo(b.x, b.y - 4);
                ctx.lineTo(b.x, b.y + 4);
                ctx.stroke();
            }
            else if (b.type === "sniper") {
                ctx.beginPath();
                ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                const sniperGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, 4);
                sniperGrad.addColorStop(0, '#aaaaaa');
                sniperGrad.addColorStop(1, '#333333');
                ctx.fillStyle = sniperGrad;
                ctx.fill();
                
                // Crosshair effect
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(b.x - 6, b.y);
                ctx.lineTo(b.x + 6, b.y);
                ctx.moveTo(b.x, b.y - 6);
                ctx.lineTo(b.x, b.y + 6);
                ctx.stroke();
            }
            else if (b.type === "zap") {
                // Draw lightning bolt effect
                ctx.beginPath();
                ctx.moveTo(b.x, b.y);
                
                // Create jagged lightning effect
                const segments = 5;
                const dx = (b.tx - b.x) / segments;
                const dy = (b.ty - b.y) / segments;
                
                for (let i = 1; i <= segments; i++) {
                    const offsetX = (Math.random() - 0.5) * 15;
                    const offsetY = (Math.random() - 0.5) * 15;
                    ctx.lineTo(
                        b.x + dx * i + offsetX,
                        b.y + dy * i + offsetY
                    );
                }
                
                ctx.strokeStyle = "#FFFF00";
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Glow effect
                ctx.strokeStyle = "rgba(255, 255, 150, 0.7)";
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            else if (b.type === "explosion") {
                const gradient = ctx.createRadialGradient(
                    b.x, b.y, 0,
                    b.x, b.y, b.radius
                );
                gradient.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
                gradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Inner explosion
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
                ctx.fill();
                
                b.lifetime--;
            }
            else {
                // Default projectile (magic)
                ctx.beginPath();
                ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = b.color;
                ctx.fill();
            }
        }
        
        // Start/end arrows
        drawArrow(path[0].x, path[0].y, Math.atan2(path[1].y-path[0].y, path[1].x-path[0].x), "#21c84c");
        drawArrow(path[path.length-1].x, path[path.length-1].y, 
                  Math.atan2(path[path.length-1].y-path[path.length-2].y, 
                            path[path.length-1].x-path[path.length-2].x), "#e32c1c");
    }

    function drawArrow(x, y, angle, color) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(-18, -14);
        ctx.lineTo(12, 0);
        ctx.lineTo(-18, 14);
        ctx.lineTo(-10, 0);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 6;
        ctx.globalAlpha = 0.92;
        ctx.fill();
        ctx.restore();
    }

    // Event listeners
    window.addEventListener('load', function() {
        resizeCanvas();
        updateUI();
        
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('touchstart', handleCanvasClick, { passive: false });
        
        startButton.addEventListener('click', function() {
            if (!gameState.waveActive && gameState.wave <= MAX_WAVE) {
                startWave();
            }
        });
        
        window.addEventListener('resize', resizeCanvas);
    });
</script>
</body>
</html>