<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legion of Towers</title>
    <!-- Add PeerJS CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>  
    
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Title Screen -->
    <div id="titleScreen">
        <h1>Legion of Towers</h1>

        <div class="menu-section">
            <div class="menu-title">Difficulty</div>
            <div class="menu-options">
                <button class="menu-btn selected" data-difficulty="easy">Easy</button>
                <button class="menu-btn locked" data-difficulty="medium">Medium</button>
                <button class="menu-btn locked" data-difficulty="hard">Hard</button>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-title">Select Map</div>
            <div class="maps-container">
                <button class="menu-btn selected" data-map="1">Forest</button>
                <button class="menu-btn locked" data-map="2">Desert</button>
                <button class="menu-btn locked" data-map="3">Mountains</button>
                <button class="menu-btn locked" data-map="4">Canyon</button>
                <button class="menu-btn locked" data-map="5">Valley</button>
                <button class="menu-btn locked" data-map="6">Hexagon</button>
            </div>
        </div>

        <button class="menu-btn start-btn">Start Game</button>
        <button class="menu-btn multiplayer-btn">Multiplayer</button>
    </div>

    <!-- Multiplayer Menu -->
    <div id="multiplayerMenu">
        <h1 class="multiplayer-title">Multiplayer Menu</h1>
        
        <div class="multiplayer-container">
            <div class="multiplayer-left">
                <div class="connection-status">
					<label>Lobby Code:</label>
					<input type="text" id="lobbyCodeDisplay" readonly>
                    <h3>Connection Status</h3>
                    <div id="connectionStatus">Disconnected</div>
                </div>

                <div class="menu-section">
                    <div class="menu-title">Join Game</div>
                    <div class="input-group">
                        <label for="playerName">Your Name:</label>
                        <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
                    </div>
                    <div class="menu-options">
                        <button class="menu-btn" id="hostLobbyBtn">Host a Lobby</button>
                        <button class="menu-btn" id="joinRandomBtn">Join Random</button>
                    </div>
                    
                    <div class="input-group">
                        <label for="lobbyCode">Lobby Code:</label>
                        <input type="text" id="lobbyCode" placeholder="Enter lobby code to join">
                    </div>
                    <button class="menu-btn" id="joinLobbyBtn">Join Lobby</button>
                </div>
            </div>
            
            <div class="multiplayer-right">
                <div class="lobby-list">
                    <h3>Available Lobbies</h3>
                    <div id="lobbyListContainer">
                        <div class="lobby-item">No lobbies available</div>
                    </div>
                </div>

                <div class="player-list">
                    <h3>Connected Players</h3>
                    <div id="playerListContainer">
                        <div class="player-item">
                            <span>No players connected</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="menu-section" id="hostControls" style="display: none;">
            <div class="menu-title">Host Controls</div>
            <button class="menu-btn start-btn" id="startMultiplayerGame">Start Multiplayer Game</button>
        </div>

        <button class="menu-btn back-btn" id="backToMainBtn">Back to Main Menu</button>
    </div>

    <!-- Game Container -->
    <div id="gameContainer">
        <div id="ui">
            <div id="resources-left">
                <div class="resource life">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/lifes.svg" width="25" height="25">
                    <span id="lifeAmount">20/20</span>
                </div>
                <div class="resource gold">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/gold.svg" width="25" height="25">
                    <span id="goldAmount">20000</span>
                </div>
                <div class="resource bluecrystal">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/dia.svg" width="25" height="25">
                    <span id="crystalAmount">5</span>
                </div>
            </div>
            <div id="resources-right">
                <div class="resource wave">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/wave.svg" width="25" height="25">
                    <span id="waveNumber">1/5</span>
                </div>
                <div class="resource enemies">
                    <img src="https://bodenbac.github.io/GameList-Luis/Assets/LOT/Other/enemy.svg" width="25" height="25">
                    <span id="enemiesKilled">0/10</span>
                </div>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="towerBar">
            <!-- Tower icons will be added here dynamically -->
        </div>
        <div id="towerMenu"></div>
        <div id="upgradeMenu"></div>
        <button id="startButton">Next Wave</button>

        <div id="playerIndicators" style="display:none; position:absolute; top:10px; right:10px; z-index:1000; background:rgba(0,0,0,0.7); padding:8px; border-radius:8px; color:white;">
            <div>Player <span id="playerNumber">1</span></div>
            <div>Connected: <span id="connectedPlayers">1/2</span></div>
        </div>
    </div>
	
	<button id="toggleChat">ðŸ’¬</button>
    <div id="chatContainer">
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Type a message...">
        <button id="sendChat">Send</button>
    </div>

<script>
    // ======================
    // MULTIPLAYER SYSTEM
    // ======================
    class MultiplayerManager {
        constructor() {
            this.isHost = false;
            this.isConnected = false;
            this.playerName = '';
            this.lobbyCode = '';
            this.connection = null;
            this.connectedPlayers = new Map();
            this.availableLobbies = [];
            this.playerRole = null;
            this.peer = null;
            this.connections = new Map();
            
            this.setupEventListeners();
            this.updateUI();
        }

        setupEventListeners() {
            document.getElementById('hostLobbyBtn').addEventListener('click', () => this.hostLobby());
            document.getElementById('joinRandomBtn').addEventListener('click', () => this.joinRandomLobby());
            document.getElementById('joinLobbyBtn').addEventListener('click', () => this.joinLobby());
            document.getElementById('backToMainBtn').addEventListener('click', () => this.backToMain());
            document.getElementById('startMultiplayerGame').addEventListener('click', () => this.startGame());
            
            // Chat controls
            document.getElementById('toggleChat').addEventListener('click', () => {
                const chat = document.getElementById('chatContainer');
                chat.style.display = chat.style.display === 'none' ? 'block' : 'none';
            });
            
            document.getElementById('sendChat').addEventListener('click', () => this.sendChatMessage());
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.sendChatMessage();
            });
        }
		
		async initializePeerJS() {
            // Create a new Peer
            this.peer = new Peer();
            
            return new Promise((resolve, reject) => {
                this.peer.on('open', (id) => {
                    console.log('PeerJS connected with ID:', id);
                    resolve(id);
                });
                
                this.peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    reject(err);
                });
            });
        }

        // Ã„nderung in der hostLobby-Methode
		async hostLobby() {
			const playerName = document.getElementById('playerName').value.trim();
			if (!playerName) {
				this.showCustomAlert('Please enter your name first!');
				return;
			}

                        try {
                                if (this.peer) {
                                        this.peer.destroy();
                                }

                                this.peer = new Peer({
                                        debug: 3,
                                        config: {
                                                iceServers: [
                                                        { urls: 'stun:stun.l.google.com:19302' },
                                                        { urls: 'stun:stun1.l.google.com:19302' }
						]
					}
				});

				const peerId = await new Promise((resolve, reject) => {
					this.peer.on('open', resolve);
					this.peer.on('error', reject);
					setTimeout(() => reject('PeerJS initialization timeout'), 15000);
				});

				// Store the full peer ID
                                this.lobbyCode = peerId;
                                this.playerName = playerName;
                                this.playerRole = 'host';

                                // Ensure the local player list always starts clean
                                this.connections.clear();
                                this.connectedPlayers.clear();
                                this.connectedPlayers.set(this.peer.id, {
                                        id: this.peer.id,
                                        name: this.playerName,
                                        role: 'host',
                                        status: 'connected'
                                });
				
				// Update UI - MAKE SURE THIS ELEMENT EXISTS
				const lobbyDisplay = document.getElementById('lobbyCodeDisplay');
				if (lobbyDisplay) {
					lobbyDisplay.value = peerId;
				} else {
					console.error('lobbyCodeDisplay element not found!');
					// Fallback: Show alert with the code
					this.showCustomAlert(`Lobby created! Code: ${peerId}`);
				}

				// Set up connection handler
                                this.peer.on('connection', (conn) => {
                                        console.log('Incoming connection:', conn.peer);
                                        this.setupConnection(conn);
                                });

                                this.isHost = true;
                                this.isConnected = true;
                                this.updateUI();

                                // Allow the host to access the chat immediately
                                document.getElementById('toggleChat').style.display = 'block';

                        } catch (error) {
				console.error('Failed to host lobby:', error);
				if (this.peer) this.peer.destroy();
				this.showCustomAlert(`Failed to create lobby: ${error}`);
			}
		}
		
		lobbyCodeToPeerId(lobbyCode) {
            // Since we create lobby codes from the first 6 characters of peer ID,
            // we need the full peer ID to connect. In a real implementation,
            // you'd have a server to map codes to full peer IDs.
            // For this demo, we'll assume the full peer ID is available
            // This is a limitation of the current implementation
            return lobbyCode.trim();
        }

        setupConnection(conn) {
            conn.on('open', () => {
                console.log('Connection established with:', conn.peer);
                
                // Add to connections map
                this.connections.set(conn.peer, conn);
                
                // Send welcome message with our info
                this.sendMessageToConnection(conn, {
                    type: 'playerInfo',
                    peerId: this.peer.id,
                    playerName: this.playerName,
                    role: this.playerRole
                });
                
                // Update player list if we're host
                if (this.isHost) {
                    this.connectedPlayers.set(conn.peer, {
                        id: conn.peer,
                        name: conn.metadata?.playerName || 'Guest',
                        role: 'guest',
                        status: 'connected'
                    });
                    this.updatePlayerList();
                }
            });
            
            // Handle incoming messages
            conn.on('data', (data) => this.handleMessage(data, conn.peer));
            
            conn.on('close', () => {
                console.log('Connection closed with:', conn.peer);
                this.connections.delete(conn.peer);
                this.connectedPlayers.delete(conn.peer);
                this.updatePlayerList();
            });
            
            conn.on('error', (err) => {
                console.error('Connection error with', conn.peer, ':', err);
            });
        }
		
        findHostPeerId(lobbyCode) {
            // In a real implementation, you'd look up the peer ID from the lobby code
            // For this demo, we'll just use the lobby code directly (since we're not using a server)
            return lobbyCode.trim();
        }

        joinRandomLobby() {
            alert('Random lobby joining is not implemented in this demo. Please use a specific lobby code.');
        }

        async joinLobby() {
            const playerName = document.getElementById('playerName').value.trim();
            const lobbyCodeInput = document.getElementById('lobbyCode').value.trim();

            if (!playerName) {
                this.showCustomAlert('Please enter your name first!');
                return;
            }

            if (!lobbyCodeInput) {
                this.showCustomAlert('Please enter a lobby code!');
                return;
            }

            try {
                console.log('Joining lobby with code:', lobbyCodeInput);
                
                // Check if PeerJS is available
                if (typeof Peer === 'undefined') {
                    throw new Error('PeerJS library not loaded. Please check your internet connection.');
                }

                // Initialize PeerJS
                this.peer = new Peer({
					debug: 3, // Increased verbosity
					config: {
						iceServers: [
							{ urls: 'stun:stun.l.google.com:19302' },
							{ urls: 'stun:stun1.l.google.com:19302' },
							{ urls: 'stun:stun2.l.google.com:19302' }
						]
					},
					iceTransportPolicy: 'all'
				});

                const peerId = await new Promise((resolve, reject) => {
                    let resolved = false;
                    
                    this.peer.on('open', (id) => {
                        if (!resolved) {
                            resolved = true;
                            resolve(id);
                        }
                    });
                    
                    this.peer.on('error', (err) => {
                        if (!resolved) {
                            resolved = true;
                            reject(err);
                        }
                    });
                    
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('Connection timeout'));
                        }
                    }, 15000);
                });

                this.playerName = playerName;
                this.isHost = false;
                this.playerRole = 'guest';

                // Convert lobby code back to host peer ID
                //const hostPeerId = this.lobbyCodeToPeerId(lobbyCode);
                                const hostPeerId = lobbyCodeInput; // Expect full ID
                                console.log("Connecting to:", hostPeerId); // Debug log

                // Connect to host
                const conn = this.peer.connect(hostPeerId, {
                    reliable: true,
                    metadata: {
                        playerName: playerName,
                        role: 'guest'
                    }
                });

                // Setup connection
                await new Promise((resolve, reject) => {
                    let resolved = false;
                    
                    conn.on('open', () => {
                        if (!resolved) {
                            resolved = true;
                            console.log('Connected to host successfully');
                            this.setupConnection(conn);
                            resolve();
                        }
                    });
                    
                    conn.on('error', (err) => {
						if (!resolved) {
							resolved = true;
							console.error('Connection error:', err);
							reject(new Error('Failed to connect to lobby. Please check the code and try again.'));
							this.showCustomAlert('Connection failed. Please check the lobby code and try again.', 'Error');
						}
					});
                    
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            reject(new Error('Connection timeout. Host might be offline.'));
                        }
                    }, 10000);
                });

                // Add self to player list
                this.connectedPlayers.set(peerId, {
                    id: peerId,
                    name: playerName,
                    role: 'guest',
                    status: 'connected'
                });

                this.lobbyCode = hostPeerId;
                this.isConnected = true;
                this.updateUI();
                this.showCustomAlert(`Successfully joined lobby: ${hostPeerId}`, 'Success');
                
                // Show chat controls
                document.getElementById('toggleChat').style.display = 'block';
                
            } catch (error) {
                console.error('Failed to join lobby:', error);
                this.showCustomAlert(`Failed to join lobby: ${error.message}`, 'Error');
                
                // Cleanup on error
                if (this.peer) {
                    this.peer.destroy();
                    this.peer = null;
                }
                this.isConnected = false;
                this.updateUI();
            }
        }

        joinSpecificLobby(lobbyCode, playerName) {
            this.playerName = playerName;
            this.lobbyCode = lobbyCode;
            this.isHost = false;
            this.isConnected = true;
            this.playerRole = 'guest';

            // Simulate joining
            this.connectedPlayers.set('guest', {
                name: playerName,
                role: 'guest',
                status: 'connected'
            });

            // Simulate host already being there
            this.connectedPlayers.set('host', {
                name: 'Host Player',
                role: 'host',
                status: 'connected'
            });

            this.updateUI();
            alert(`Joined lobby: ${lobbyCode}`);
        }

        backToMain() {
            // Cleanup connections
            if (this.peer) {
                this.peer.destroy();
                this.peer = null;
            }
            
            this.connections.clear();
            this.connectedPlayers.clear();
            
            // Reset state
            this.isHost = false;
            this.isConnected = false;
            this.lobbyCode = '';
            this.playerRole = null;
            
            // Hide UI elements
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('titleScreen').style.display = 'flex';
            document.getElementById('toggleChat').style.display = 'none';
            
            this.updateUI();
        }

        updateLobbyList() {
            const container = document.getElementById('lobbyListContainer');
            
            if (this.availableLobbies.length === 0) {
                container.innerHTML = '<div class="lobby-item">No lobbies available</div>';
                return;
            }

            container.innerHTML = '';
            this.availableLobbies.forEach(lobby => {
                const item = document.createElement('div');
                item.className = 'lobby-item';
                item.innerHTML = `
                    <div>Code: ${lobby.code}</div>
                    <div>Host: ${lobby.host}</div>
                    <div>Players: ${lobby.players}/${lobby.maxPlayers}</div>
                `;
                item.addEventListener('click', () => {
                    document.getElementById('lobbyCode').value = lobby.code;
                });
                container.appendChild(item);
            });
        }

        updatePlayerList() {
            const container = document.getElementById('playerListContainer');
            
            if (this.connectedPlayers.size === 0) {
                container.innerHTML = '<div class="player-item"><span>No players connected</span></div>';
                return;
            }

            container.innerHTML = '';
            this.connectedPlayers.forEach((player) => {
                const item = document.createElement('div');
                item.className = 'player-item';
                
                item.innerHTML = `
                    <span>${player.name}</span>
                    <span class="player-status">
                        ${player.role === 'host' ? 'Host' : 'Guest'}
                    </span>
                `;
                container.appendChild(item);
            });
        }

        updateUI() {
            // Update connection status
            const statusEl = document.getElementById('connectionStatus');
            if (this.isConnected) {
                statusEl.textContent = `Connected - ${this.isHost ? 'Hosting' : 'Guest'} - Code: ${this.lobbyCode}`;
                statusEl.style.color = '#27ae60';
            } else {
                statusEl.textContent = 'Disconnected';
                statusEl.style.color = '#e74c3c';
            }

            // Update player list
            this.updatePlayerList();

            // Show/hide host controls
            const hostControls = document.getElementById('hostControls');
            if (this.isHost && this.isConnected) {
                hostControls.style.display = 'block';
            } else {
                hostControls.style.display = 'none';
            }
        }

        // Network message handling (simplified for demo)
        sendMessage(type, data) {
            // In a real implementation, this would send over WebRTC
            console.log('Sending message:', { type, data });
            
            // Simulate receiving the message for demo
            setTimeout(() => {
                this.handleMessage({ type, data, fromPlayer: this.playerRole === 'host' ? 'guest' : 'host' });
            }, 100);
        }
		
		sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;
            
            // Display locally
            this.displayChatMessage(this.playerName, message);
            
            // Broadcast to others
            this.broadcastMessage({
                type: 'chat',
                sender: this.playerName,
                message: message
            });
            
            input.value = '';
        }
		
		sendMessageToConnection(conn, message) {
            try {
                if (conn && conn.open) {
                    conn.send(message);
                } else {
                    console.warn('Attempted to send message to closed connection');
                }
            } catch (error) {
                console.error('Failed to send message:', error);
            }
        }

        broadcastMessage(message, excludePeerId = null) {
            this.connections.forEach((conn, peerId) => {
                if (peerId !== excludePeerId && conn.open) {
                    this.sendMessageToConnection(conn, message);
                }
            });
        }
		
		displayChatMessage(sender, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        handleMessage(message, fromPeer) {
            console.log('Received message from', fromPeer, ':', message);
            
            switch (message.type) {
                case 'playerInfo':
                    // Update player info
                    this.connectedPlayers.set(message.peerId, {
                        id: message.peerId,
                        name: message.playerName,
                        role: message.role,
                        status: 'connected'
                    });
                    this.updatePlayerList();
                    break;
                    
                case 'chat':
                    this.displayChatMessage(message.sender, message.message);
                    break;
                    
                case 'towerPlaced':
                    this.handleTowerPlaced(message.data);
                    break;
                    
                case 'towerUpgraded':
                    this.handleTowerUpgraded(message.data);
                    break;
                    
                case 'waveStarted':
                    this.handleWaveStarted(message.data);
                    break;
                    
                case 'gameState':
                    this.handleGameStateUpdate(message.data);
                    break;
                case 'gameStart':
                    // Hide menus for guest
                    document.getElementById('multiplayerMenu').style.display = 'none';
                    document.getElementById('titleScreen').style.display = 'none';
                    document.getElementById('startButton').style.display = 'block';
                    document.getElementById('startButton').style.pointerEvents = 'auto';
                    
                    // Sync game settings
                    gameConfig.isMultiplayer = true;
                    gameConfig.playerRole = 'guest';
                    gameConfig.map = data.map;
                    gameConfig.difficulty = data.difficulty;
                    
                    // Sync game state
                    gameState.wave = data.wave;
                    gameState.gold = data.gold;
                    
                    // Start game for guest
                    initGame();
                    mainLoop();
                    break;
            }
        }
		
		// JavaScript fÃ¼r benutzerdefinierte Alerts
		showCustomAlert(message, title = 'Alert') {
            const overlay = document.createElement('div');
            overlay.className = 'custom-alert-overlay';
            
            const alertBox = document.createElement('div');
            alertBox.className = 'custom-alert';
            alertBox.innerHTML = `
                <h3>${title}</h3>
                <p>${message}</p>
                <div class="custom-alert-buttons">
                    <button class="custom-alert-btn retry">OK</button>
                </div>
            `;
            
            const okBtn = alertBox.querySelector('.retry');
            okBtn.addEventListener('click', () => {
                document.body.removeChild(overlay);
                document.body.removeChild(alertBox);
            });
            
            document.body.appendChild(overlay);
            document.body.appendChild(alertBox);
        }

        handleTowerPlaced(data) {
            // Add tower placed by other player
            const tower = {
                x: data.x,
                y: data.y,
                type: {...data.type},
                lastShot: 0,
                level: 1,
                upgrades: {
                    dmg: 0,
                    rate: 0,
                    range: 0,
                    slow: 0,
                    special: data.type.upgrades.special ? 
                        {...data.type.upgrades.special, purchased: false} : null
                },
                flameWidth: data.type.bulletType === "flame" ? 10 : 0,
                lastFreeze: 0,
                placedBy: data.playerId
            };
            
            towers.push(tower);
        }

        handleTowerUpgraded(data) {
            // Find and upgrade tower
            const tower = towers.find(t => t.x === data.x && t.y === data.y);
            if (tower) {
                Object.assign(tower.upgrades, data.upgrades);
                tower.level = data.level;
            }
        }

        handleWaveStarted(data) {
            if (!gameState.waveActive) {
                startWave();
            }
        }

        handleGameStateUpdate(data) {
            // Sync shared game state (lives, wave number, etc.)
            if (data.lives !== undefined) gameState.lives = data.lives;
            if (data.wave !== undefined) gameState.wave = data.wave;
            updateUI();
        }

        startGame() {
            if (!this.isHost) {
                this.showCustomAlert('Only the host can start the game!');
                return;
            }

            // Count only connected guests (excluding host)
            const connectedPlayers = [...this.connectedPlayers.values()].filter(p => p.role === 'guest');
            
            if (connectedPlayers.length < 1) {
                this.showCustomAlert('Need at least 1 other player to start!');
                return;
            }

            // Hide menus and show game UI for host
            document.getElementById('multiplayerMenu').style.display = 'none';
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('startButton').style.pointerEvents = 'auto';
            
            // Initialize multiplayer game
            gameConfig.isMultiplayer = true;
            gameConfig.playerRole = this.playerRole;
            gameConfig.connectedPlayers = this.connectedPlayers;
            
            // Broadcast game start to all players
            this.broadcastMessage({
                type: 'gameStart',
                wave: gameState.wave,
                gold: gameState.gold,
                map: gameConfig.map,
                difficulty: gameConfig.difficulty
            });

            // Start game for host
            initGame();
            mainLoop();
        }

        // Send multiplayer game events
        sendMessage(type, data) {
            this.broadcastMessage({
                type: type,
                data: data,
                timestamp: Date.now()
            });
        }    
    }

    // Create multiplayer manager instance
    const multiplayerManager = new MultiplayerManager();

    // ======================
    // GAME CONFIGURATION
    // ======================
    let gameConfig = {
        difficulty: 'easy',
        map: 1,
        unlockedMaps: [1, 2, 3, 4, 5, 6],
        unlockedDifficulties: ['easy'],
        isMultiplayer: false,
        playerRole: null,
        connectedPlayers: null,
        difficulties: {
            easy: { gold: 300, enemyHpMultiplier: 2.0 },
            medium: { gold: 200, enemyHpMultiplier: 3.5 },
            hard: { gold: 150, enemyHpMultiplier: 5.0 }
        }
    };

    // Enemy tier system - T1 (green) to T5 (black)
    const enemyTiers = [
        {   // T1 - Green (weakest)
            name: "T1 Grunt",
            color: "#4CAF50",
            hp: 50,
            speed: 1.4,
            goldValue: 10,
            tier: 1
        },
        {   // T2 - Blue
            name: "T2 Soldier",
            color: "#2196F3",
            hp: 120,
            speed: 1.1,
            goldValue: 20,
            tier: 2
        },
        {   // T3 - Purple
            name: "T3 Elite",
            color: "#9C27B0",
            hp: 250,
            speed: 0.9,
            goldValue: 35,
            tier: 3
        },
        {   // T4 - Red
            name: "T4 Champion",
            color: "#F44336",
            hp: 450,
            speed: 0.7,
            goldValue: 55,
            tier: 4
        },
        {   // T5 - Black (strongest)
            name: "T5 Boss",
            color: "#212121",
            hp: 800,
            speed: 0.5,
            goldValue: 80,
            tier: 5
        }
    ];

    // ======================
    // MENU EVENT LISTENERS
    // ======================
    
    // Multiplayer button event listener
    document.querySelector('.multiplayer-btn').addEventListener('click', function() {
        document.getElementById('titleScreen').style.display = 'none';
        document.getElementById('multiplayerMenu').style.display = 'flex';
    });

    // Title screen logic (difficulty and map selection)
    document.querySelectorAll('[data-difficulty]').forEach(btn => {
        btn.addEventListener('click', function() {
            if (this.classList.contains('locked')) return;
            document.querySelectorAll('[data-difficulty]').forEach(b => b.classList.remove('selected'));
            this.classList.add('selected');
            gameConfig.difficulty = this.dataset.difficulty;
        });
    });

    document.querySelectorAll('[data-map]').forEach(btn => {
        btn.addEventListener('click', function() {
            const mapNum = parseInt(this.dataset.map);
            if (this.classList.contains('locked') || !gameConfig.unlockedMaps.includes(mapNum)) return;
            
            document.querySelectorAll('[data-map]').forEach(b => b.classList.remove('selected'));
            this.classList.add('selected');
            gameConfig.map = mapNum;
        });
    });

    // Main game loop function
    function mainLoop() {
        update();
        draw();
        requestAnimationFrame(mainLoop);
    }

    // Update function to handle game logic
    document.querySelector('.start-btn').addEventListener('click', function() {
        document.getElementById('titleScreen').style.display = 'none';
        document.getElementById('startButton').style.display = 'block';
        document.getElementById('startButton').style.pointerEvents = 'auto';
        initGame();
        mainLoop(); // Now this will work
    });

    // Window resize handler
    window.addEventListener('resize', function() {
        if (document.getElementById('titleScreen').style.display === 'none') {
            resizeCanvas();
        }
    });

    // Initialize the game with selected settings
    async function initGame() {
        const difficulty = gameConfig.difficulties[gameConfig.difficulty];
        gameState.gold = difficulty.gold;

        document.body.classList.remove('in-title-screen');

        // Select map based on choice
        switch(gameConfig.map) {
            case 1: setupMap1(); break;
            case 2: setupMap2(); break;
            case 3: setupMap3(); break;
            case 4: setupMap4(); break;
            case 5: setupMap5(); break;
            case 6: setupMap6(); break;
        }

        if (gameConfig.isMultiplayer) {
            // Show player indicators
            document.getElementById('playerIndicators').style.display = 'block';
            
            // Host is player 1, guest is player 2
            if (gameConfig.playerRole === 'host') {
                gameState.playerNumber = 1;
            } else {
                gameState.playerNumber = 2;
            }
        }

        // Initialize tower bar
        setupTowerBar();

        updateUI();
        resizeCanvas(); // Important for correct display

    <script src="main.js"></script>
</body>
</html>
